
==============================================================================
.\.\functional_facilities_spec.lua
==============================================================================
     	--local k,l,_=pcall(require,\"luarocks.loader\") _=k and l.add_context(\"busted\",\"1.10.0-1\")
     	
    4	describe("Basic functional programming facilities", function()
     	  local functional
     	  
    4	  setup(function()
    2	    functional = require('functional')
    4	  end)
     	
    4	  teardown(function()
    4	  end)
     	  
    4	  describe("Map facility", function() 
    4	    it("map on empty table shall return empty table", function()
    2	      assert.are.same(functional.map({}, function(x) end), {})
    4	    end)
     	  
    4	    it("map null function on table shall return empty table", function()
   12	      assert.are.same(functional.map({1,2,3,4,5}, function(x) end), {})
    4	    end)
     	  
    4	    it("map function on table shall return table with all elements modified", function()
   12	      assert.are.same(functional.map({1,2,3,4,5}, function(x) return x*10 end), {10, 20, 30, 40, 50})
    4	    end)
     	
    4	    it("map function on table shall preserve indices", function()
    8	      assert.are.same(functional.map({['bob'] = 3,['alice'] = 4, [4] = 5}, function(x) return 2 * x + 20 end), {['bob'] = 26, ['alice'] = 28, [4] = 30})
    4	    end)
     	
    4	    it("map function can be used with tables", function()
    8	      assert.are.same(functional.map({{1,2,3}, {2,3,4}, {3,4,5}}, function(x) return x[1] end), {1,2,3})
    4	    end)
     	
    4	    it("map function can be used with strings", function()
    8	      assert.are.same(functional.map({"a", "b", "v"}, function(x) return x .. "!" end), {"a!", "b!", "v!"})
    4	    end)
    4	  end)
     	  
    4	  describe("Partitioning facility", function() 
    4	    it("if all elements satisfy predicate second table is empty", function() 
   12	      local right, wrong = functional.partition({1,2,3,4,5}, function() return true end)
    2	      assert.are.same({1,2,3,4,5}, right)
    2	      assert.are.same({}, wrong)
    4	    end)
    4	    it("if no elements satisfy predicate first table is empty", function() 
   12	      local right, wrong = functional.partition({1,2,3,4,5}, function() return false end)
    2	      assert.are.same({}, right)    
    2	      assert.are.same({1,2,3,4,5}, wrong)
    4	    end)
    4	    it("elements satisfying predicate to go first table, others to the second", function() 
   12	      local right, wrong = functional.partition({1,2,3,4,5}, function(x) return x > 3 end)
    2	      assert.are.same({[4] = 4,[5] = 5}, right)
    2	      assert.are.same({1,2,3}, wrong)    
    4	    end)
    4	    it("keys are preserved during partitioning", function() 
   12	      local right, wrong = functional.partition({['a'] = 1, ['b'] = 2, ['alice'] = 3, [8] = 4, ['bar'] = 5}, function(x) return x < 3 end)
    2	      assert.are.same({['a'] = 1,['b'] = 2}, right)
    2	      assert.are.same({['alice'] = 3, [8] = 4, ['bar'] = 5}, wrong)    
    4	    end)    
    4	  end)
     	  
    4	  describe("Filter facility", function()
    4	    it("filter on empty table shall return empty table", function()
    2	      assert.are.same(functional.filter({}, function(x) end), {})
    4	    end)  
     	
    4	    it("filter shall return equal table if all elements fulfill predicate", function()
    8	      assert.are.same(functional.filter({1,2,3}, function(x) return true end), {1,2,3})
    4	    end)  
     	 
    4	    it("filter shall return empty table if no elements fulfill predicate", function()
    8	      assert.are.same(functional.filter({1,2,3}, function(x) return false end), {})
    4	    end)  
     	
    4	    it("filter shall return table with elements fulfilling predicate", function()
   10	      assert.are.same(functional.filter({1,2,3,4}, function(x) return x>2 end), {[3] = 3,[4] = 4})
    4	    end)  
     	
    4	    it("filter shall preserve indices", function()
    8	      assert.are.same(functional.filter({['bob'] = 1, ['alice'] = 2, [100] = 3}, function(x) return x <= 2 end), {['bob'] = 1, ['alice'] = 2})
    4	    end)
     	    
    4	    it("filter shall work with tables", function()
   10	      assert.are.same(functional.filter({{}, {1,2}, {1,2,3}, {1,2,3,4}}, function(x) return #x < 3 end), {{}, {1,2}})
    4	    end)
     	    
    4	    it("filter shall work with strings", function()
    8	      assert.are.same(functional.filter({'a', 'ala', 'alice'}, function(x) return x .. 'la' == 'ala' end), {'a'})
    4	    end)
    4	  end)
     	  
    4	  describe("First facility", function()
    4	    it("first shall return nil if no element satisfies predicate", function() 
    8	      assert.is_true(functional.first({1,2,3}, function(x) return false end) == nil)
    4	    end)  
    4	    it("first shall index of first element satisfying predicate", function()
    4	      assert.is_true(functional.first({1,2,3}, function(x) return true end) == 1)
    4	    end)  
    4	    it("first shall index of any element satisfying predicate in associative array", function() 
    6	      local index = functional.first({['a'] = 1,['b'] = 2,['c'] = 3}, function(x) return x > 1 end)
    2	      assert.is_true(index == 'c' or index == 'b')
    4	    end)
    4	  end)
     	  
    4	  describe("All facility", function()
    4	    it("all shall return true for empty table", function()
    2	      assert.is_true(functional.all({}, function(x) return false end))
    4	    end)
     	    
    4	    it("all shall return false if table contains an element not fulfilling predicate", function()
    4	      assert.is_false(functional.all({1}, function(x) return false end))
    4	    end)
     	
    4	    it("all shall return true if table contains only elements fulfilling predicate", function()
    6	      assert.is_true(functional.all({1, 2}, function(x) return x ~= 0 end))
    4	    end)
     	    
    4	    it("all shall return false if table contains at least one element not fulfilling predicate", function()
   14	      assert.is_false(functional.all({1, 2, 4, 6, 7, 0}, function(x) return x ~= 0 end))
    4	    end)
     	    
    4	    it("all shall work with tables", function()
    6	      assert.is_true(functional.all({{1, 2}, {1}}, function(x) return #x ~= 0 end))
    4	    end)
     	    
    4	    it("all shall work with strings", function()
    6	      assert.is_true(functional.all({'a', 'b'}, function(x) return x ~= 'c' end))
    4	    end)    
    4	  end)
     	  
    4	  describe("Any facility", function()
    4	    it("any shall return false for empty table", function()
    2	      assert.is_false(functional.any({}, function(x) return false end))
    4	    end)
     	    
    4	    it("any shall return false if table contains only elements not fulfilling predicate", function()
    4	      assert.is_false(functional.any({1}, function(x) return false end))
    4	    end)
     	
    4	    it("any shall return true if table contains only elements fulfilling predicate", function()
    4	      assert.is_true(functional.any({1, 2}, function(x) return x ~= 0 end))
    4	    end)
     	    
    4	    it("any shall return false if table contains only elements not fulfilling predicate", function()
    6	      assert.is_false(functional.any({1, 2}, function(x) return x == 0 end))
    4	    end)
     	    
    4	    it("any shall return true if table contains at least one element fulfilling predicate", function()
   14	      assert.is_true(functional.any({1, 2, 4, 6, 7, 0}, function(x) return x == 0 end))
    4	    end)
     	    
    4	    it("any shall work with tables", function()
    4	      assert.is_true(functional.any({{1, 2}, {1}}, function(x) return #x == 2 end))
    4	    end)
     	    
    4	    it("any shall work with strings", function()
    6	      assert.is_true(functional.any({'a', 'b'}, function(x) return x == 'b' end))
    4	    end)    
    4	  end)
     	  
    4	  describe("empty facility", function() 
    4	    it("empty table is empty", function() 
    2	      assert.is_true(functional.empty({}))
    2	      assert.is_true(functional.empty({nil}))
    4	    end) 
    4	    it("nonempty table is not empty", function() 
    2	      assert.is_false(functional.empty({2}))
    2	      assert.is_false(functional.empty({2.2,3}))
    2	      assert.is_false(functional.empty({1232.123}))
    2	      assert.is_false(functional.empty({'sasa'}))
    2	      assert.is_false(functional.empty({{}}))
    2	      assert.is_false(functional.empty({function() end}))
    2	      assert.is_false(functional.empty({{},{}}))
    2	      assert.is_false(functional.empty({{},'a',222}))
    2	      assert.is_false(functional.empty({true}))
    2	      assert.is_false(functional.empty({false}))
    4	    end)
    4	  end)
     	  
    4	  describe("zip_with facility", function()
    4	    it("zip_with shall return table of sums if sum is the function", function() 
    2	      assert.are.same({2,5,10}, functional.zip_with(functional.sum, {1,2,5}, {1,3,5}))
    4	    end)
    4	    it("zip_with shall return table of concatenated strings if concatenation is the function", function() 
    2	      assert.are.same({'11bob','23alice','55john'}, functional.zip_with(functional.concatenate, {1,2,5}, {1,3,5}, {'bob', 'alice', 'john'}))
    4	    end)
    4	  end)
     	  
    4	  describe("Zip facility", function() 
    4	    it("zip on nothing shall return nil", function()
    2	      assert.is_true(functional.zip() == nil)    
    4	    end)
    4	    it("zip on one table shall return one - element tables with its values", function()
    2	      assert.are.same(functional.zip({1,2}), {{1}, {2}})    
    4	    end)
    4	    it("zip shall join tables by keys", function()
    2	      assert.are.same(functional.zip({1,2}, {4,5}, {100, 200}), {{1, 4, 100}, {2, 5, 200}})    
    4	    end)
    4	    it("zip shall join tables by keys, empty elements shall be nil", function()
    2	      assert.are.same(functional.zip({1,2,3,10}, {4,5,12}, {100, 200}, {1000}), {{1, 4, 100, 1000}, {2, 5, 200}, {3, 12}, {10}})    
    4	    end)
    4	    it("zip shall join tables by keys and work even with string indices", function()
    4	      assert.are.same(functional.zip({['a'] = 1, ['bob'] = 2,3}, {4,5,['bob'] = 12}, {['a'] = 100, 200}), 
    2	        {[1] = {3, 4, 200}, [2] = {[2] = 5}, ['a']={[1] = 1, [3] = 100}, ['bob'] = {[1] = 2, [2] = 12}})    
    4	    end)
    4	    it("zip shall also work with strings", function()
    2	      assert.are.same(functional.zip({'a', 'b'}, {'l', 'o'}, {'i', 'b'}, {'c'}, {'e'}),{{'a', 'l', 'i', 'c', 'e'}, {'b', 'o', 'b'}})    
    4	    end)
    4	    it("zip shall also work with inner tables and mixed types", function()
    2	      assert.are.same(functional.zip({{'a'}, {}}, {1, 'b'}, {'i', 0}, {{'c'}, {'b'}}, {'e'}),{{{'a'}, 1, 'i', {'c'}, 'e'}, {{}, 'b', 0, {'b'}}})    
    4	    end)
    4	  end)
     	  
    4	  describe("Fold facility", function()
    4	    it("fold on empty table shall return starting accumulator", function()
    2	      assert.are.equal(1, functional.fold({}, function(acc, x) return acc * x end, 1))
    4	    end)    
    4	    it("fold with muliplying calculates product of a table", function()
   12	      assert.are.equal(120, functional.fold({1,2,3,4,5}, function(acc, x) return acc * x end, 1))
    4	    end)    
    4	    it("fold with sum calculates sum of a table", function()
   12	      assert.are.equal(15, functional.fold({1,2,3,4,5}, function(acc, x) return acc + x end, 0))
    4	    end)
    4	    it("fold with sum calculates sum of a table and starting accumulator", function()
   12	      assert.are.equal(115, functional.fold({1,2,3,4,5}, function(acc, x) return acc + x end, 100))
    4	    end)
    4	    it("fold with inserting creates a table with given indices", function()
   12	      assert.are.same({1,2,3,4,5}, functional.fold({1,2,3,4,5}, function(acc, x) acc[x] = x; return acc end, {}))
    4	    end)
    4	    it("fold with concatenation merges strings", function()
   12	      assert.are.same('bob and alice', functional.fold({'bo', 'b ', 'and', ' al', 'ice'}, function(acc, x) return acc .. x end, ''))
    4	    end)
    4	  end)
     	  
    4	  describe("Forall faciity", function()
    4	    it("If every element is a table one may add an element to them", function() 
    2	      local tab = {{}, {2, 3}, {'a'}}
    8	      functional.forall(tab, function(x) x[#x + 1] = '4' end)
    2	      assert.are.same({'4'}, tab[1])
    2	      assert.are.same({2, 3, '4'}, tab[2])
    2	      assert.are.same({'a', '4'}, tab[3])
    4	    end)
    4	  end)
     	  
    4	  describe("Head and tail facilities", function() 
    4	    it("head returns first element of a sequence, tail returns rest of them", function() 
    2	      local tab = {1,2,3}
    2	      assert.equal(1, functional.head(tab))
    2	      assert.are.same({[2] = 2, [3] = 3}, functional.tail(tab))
    4	    end)
    4	    it("head returns first element of a sequence, tail returns rest of them, works for multiple same values", function() 
    2	      local tab = {1,2,3,1}
    2	      assert.equal(1, functional.head(tab))
    2	      assert.are.same({[2] = 2, [3] = 3, [4] = 1}, functional.tail(tab))
    4	    end)
    4	  end)
     	  
    4	  describe("Sum facility", function()
    4	    it("sum of empty table is 0", function()
    2	      assert.are.equal(0, functional.sum({}))  
    4	    end)
    4	    it("sum of table is sum of its elements", function()
    2	      assert.are.equal(100, functional.sum({10, 20, 30, 40}))  
    4	    end)
    4	  end)
     	  
    4	  describe("Product facility", function()
    4	    it("product of empty table is 1", function()
    2	      assert.are.equal(1, functional.product({}))  
    4	    end)
    4	    it("product of table is product of its elements", function()
    2	      assert.are.equal(100, functional.product({10, 2, 5}))  
    4	    end)
    4	  end)
     	  
    4	  describe("Concatenate facility", function()
    4	    it("concatenation of empty table is empty string", function()
    2	      assert.are.equal('', functional.concatenate({}))  
    4	    end)
    4	    it("concatenation of table is its elements concatenated", function()
    2	      assert.are.equal('alice and bob eat fruit', functional.concatenate({'alice ', 'and ', 'bob', ' ea', 't fr', 'uit'}))  
    4	    end)
    4	  end)
     	
    4	  describe("Maximum facility", function()
    4	    it("maximum of table is biggest value in table", function()
    2	      assert.are.equal(1000, functional.maximum({1000, 1,210,310}))  
    4	    end)
    4	    it("maximum of table is biggest value in associative table", function()
    2	      assert.are.equal(1000, functional.maximum({['a'] = 1000, [function() end] = 1, [{}] = 210, ['aaa'] = 310}))  
    4	    end)
    4	  end)
     	
    4	  describe("Minimum facility", function()
    4	    it("minimum of table is smallest value in table", function()
    2	      assert.are.equal(-10, functional.minimum({1,10,-10, 200}))
    4	    end)
    4	    it("minimum of table is smallest value in associative table", function()
    2	      assert.are.equal(1, functional.minimum({['a'] = 1000, [function() end] = 1, [{}] = 210, ['aaa'] = 310}))  
    4	    end)
    4	  end)
     	  
    4	  describe("Scan facility", function()
    4	    it("Scan over empty table returns table containing only accumulator", function()
    2	      assert.are.same({2}, functional.scan({}, function(x) return nil end, 2))  
    4	    end)
    4	    it("Scan over table returns table with all intermediate values", function()
    8	      assert.are.same({2, 2, 2, 2}, functional.scan({1,2,3}, function(x, y) return 2 end, 2))  
    4	    end)
    4	    it("Scan over table returns table with all intermediate accumulator results", function()
    8	      assert.are.same({2, 3, 5, 8}, functional.scan({1,2,3}, function(x, y) return x + y end, 2))  
    4	    end)
    4	    it("Scan over table works also with tables", function()
    8	      assert.are.same({0, 1, 4, 5}, functional.scan({{1}, {{}, 'a', 2}, {{}}}, function(x, y) return x + #y end, 0))  
    4	    end)
    4	    it("Scan over table works also with strings", function()
    8	      assert.are.same({'', 'a', 'ali', 'alice'}, functional.scan({'a', 'li', 'ce'}, function(x, y) return x .. y end, ""))  
    4	    end)
    4	  end)
     	  
    4	  describe("Compose facility", function() 
    4	    it("Compose square and sum returns square of sum", function() 
   46	      local square = function(x) return x * x end
   46	      local sum = function(x, y) return x + y end
    2	      local composed = functional.compose(square, sum)
     	      
   24	      for i=0,10 do
   22	        assert.equal(square(sum(i, 10*i)), composed(i, 10*i))
     	      end          
    4	    end)
     	    
    4	    it("Compose concatenate and repeat twice returns twice concatenated string", function() 
    6	      local repeat_twice = function(x) return x .. x end
   26	      local concatenate = function(...) return functional.fold({...}, function(acc, x) return acc .. x end, '') end
    2	      local composed = functional.compose(repeat_twice, concatenate)
    2	      assert.equal(repeat_twice(concatenate('a', 'l', 'i', 'c', 'e')), composed('a', 'l', 'i', 'c', 'e'))
    4	    end)
    4	  end)
     	
    4	  describe("Flip facility", function()
    4	    it("flip on subtraction shall have operands swapped", function() 
   46	      local sub = function(x, y) return x - y end
   24	      for i = 0, 10 do
   22	        assert.equal(sub(i, i + 10), functional.flip(sub)(i + 10, i))
     	      end
    4	    end)    
    4	    it("flip on concatenation shall concatenate in reverse order", function() 
   12	      assert.equal('ecila', functional.fold({'a', 'l', 'i', 'c', 'e'}, functional.flip(function(x, y) return x .. y end), ''))
    4	    end)
    4	  end)
     	  
    4	  describe("Flipall facility", function()
    4	    it("Five arguments may be flipped", function()
    6	      local decimal = function(a1, a2, a3, a4, a5) return a1 + 10*a2 + 100*a3 + 1000*a4 + 10000*a5 end
    2	      local flipped = functional.flipall(decimal, {3, 5, 2, 1, 4})
    2	      assert.equal(decimal(1,2,3,4,5), flipped(3, 5, 2, 1, 4))
    4	    end)
    4	    it("Three arguments may be flipped", function()
    6	      local concat = function(a1, a2, a3) return a1 .. a2 .. a3 end
    2	      local flipped = functional.flipall(concat, {3, 1, 2})
    2	      assert.equal(concat("alice", "and", "bob"), flipped("bob", "alice", "and"))
    4	    end) 
    4	  end)
     	  
    4	  describe("Extract args facility", function()
    4	    it("Five arguments can be extracted", function() 
    2	      local tab = {1,2,nil,4,5}
    2	      a1,a2,a3,a4,a5 = functional.extract_args(5, tab)
     	      
    2	      assert.equal(1, a1)
    2	      assert.equal(2, a2)
    2	      assert.equal(nil, a3)
    2	      assert.equal(4, a4)
    2	      assert.equal(5, a5)
    4	    end)  
    4	  end)
     	  
    4	  describe("Contains facility", function()
    4	    it("empty table shall contain nothing", function()
    2	      assert.is_false(functional.contains({}, ''))
    4	    end)
    4	    it("table with two values contains only these two values", function()
    2	      local tab = {1,2}
    2	      assert.is_false(functional.contains(tab, ''))
    2	      assert.is_false(functional.contains(tab, 100))
    2	      assert.is_false(functional.contains(tab, {}))
    2	      assert.is_false(functional.contains(tab, nil))
    2	      assert.is_true(functional.contains(tab, 1))
    2	      assert.is_true(functional.contains(tab, 2))
    4	    end)
    4	    it("contains works also with functions, strings and tables, but only named ones", function()
    2	      local f = function() end
    2	      local t = {}
    2	      local tab = {t, f, 'a', 2, 2.22}
    2	      assert.is_false(functional.contains(tab, 'bb'))
    2	      assert.is_false(functional.contains(tab, {}))
    2	      assert.is_false(functional.contains(tab, function() end))
    2	      assert.is_false(functional.contains(tab, {2}))
    2	      assert.is_false(functional.contains(tab, function(x) return x*2 end))
    2	      assert.is_false(functional.contains(tab, 2131))
    2	      assert.is_true(functional.contains(tab, t))
    2	      assert.is_true(functional.contains(tab, f))
    2	      assert.is_true(functional.contains(tab, 2))
    2	      assert.is_true(functional.contains(tab, 2.22))
    4	    end)
    4	  end)
     	  
    4	  describe("Value equality facility", function()
    4	    it("empty tables have equal values", function()
    2	      assert.is_true(functional.are_values_equal({}, {}))
    4	    end)
    4	    it("same table has equal values values", function()
    2	      tab = {1,2,3,4}
    2	      assert.is_true(functional.are_values_equal(tab, tab))  
    4	    end)
    4	    it("equal tables have equal values", function()
    2	      assert.is_true(functional.are_values_equal({1,2,3,4}, {1,2,3,4}))  
    4	    end)
    4	    it("keys do not matter in value equality", function()
    2	      assert.is_true(functional.are_values_equal({1,2,3,4}, {4,3,2,1}))    
    4	    end)
    4	    it("tables with different sizes have different values", function()
    2	      assert.is_false(functional.are_values_equal({1,1,2,3,4}, {4,3,2,1}))    
    4	    end)
    4	    it("tables with different values have different values", function()
    2	      assert.is_false(functional.are_values_equal({1,1,2,4}, {4,3,2,1}))    
    4	    end)
    4	  end)
     	  
    4	  describe("Keys facility", function() 
    4	    it("keys of an array are consecutive integers", function()
    2	      assert.is_true(functional.are_values_equal({1,2,3,4,5}, functional.keys({10, 213.1,function() end,'ala',{}})))
    4	    end)
     	  
    4	    it("keys of associative array are extracted properly", function()
    2	      assert.is_true(functional.are_values_equal({'ala', 'kota', 'ma', 1, 2}, functional.keys{['ala'] = true, ['kota'] = '1212', ['ma'] = 1231231, [1] = function() end, [2] = {}}))
    4	    end)
     	    
    4	    it("keys of associative array are extracted properly", function()
    2	      assert.is_true(functional.are_values_equal({'ala', 'kota', 'ma', 1, 2}, functional.keys{['ala'] = true, ['kota'] = '1212', ['ma'] = 1231231, [1] = function() end, [2] = {}, [3] = nil}))
    4	    end)
    4	  end)
     	  
    4	  describe("Values facility", function()
    4	    it("values of an array are extracted properly", function() 
    2	      assert.is_true(functional.are_values_equal(functional.values({1,2,3,4}), {1,2,3,4}))
    4	    end)
    4	    it("values of an associative table are extracted properly", function() 
    2	      assert.is_true(functional.are_values_equal({1,2,3,4}, functional.values({['l'] = 1,[0] = 2,['bob'] = 3,4})))
    4	    end)
    4	  end)
     	  
    4	  describe("Key sensitive flatten", function()
    4	    it("keys are preserved during flattening", function() 
    2	      assert.are.same({[1] = 1, [2] = 2, ['bob'] = 'kle'}, functional.key_sensitive_flatten({{1,2}, {['bob'] = 'kle'}}))
    4	    end)
    4	    it("value of last table overrides previous", function() 
    2	      assert.are.same({[1] = 10, [2] = 2, ['bob'] = 'kle'}, functional.key_sensitive_flatten({{1,2}, {10, ['bob'] = 'kle'}}))
    4	    end)
    4	  end)
     	 
    4	  describe("Key insensitive flatten", function()
    4	    it("keys are not preserved during flattning", function() 
    2	      assert.is_true(functional.are_values_equal({1,2,3,4,5,6,1,2,3,4}, functional.key_insensitive_flatten({{1,2,3}, {1,2,3,4}, {4,5,6}})))
    4	    end)
    4	    it("different number of occurrences matters", function() 
    2	      local f = function() end
    2	      assert.is_true(functional.are_values_equal({1,2,3,4,5,'bob', 'bob',f,6,4,1,1,1}, functional.key_insensitive_flatten({{1,2,1}, {1,3,4, 'bob'}, {4,5,1,6}, {f,'bob'}})))
    4	    end)
    4	  end)
     	  
    4	  describe("Currying facility", function()
    4	    it("five-arg function can be called four times before evaluating if curried", function() 
    4	      local curried = functional.curry(function(a,b,c,d,e) return a+b+c+d+e end, 5)
    2	      local curried_four_times = curried(1)(1)(5)(1)
    2	      assert.equal(9, curried_four_times(1))
    4	    end)
    4	    it("curried function becomes a vararg", function() 
    4	      local curried = functional.curry(function(a,b,c,d,e) return a+b+c+d+e end, 5)
    2	      local curried_three_times = curried(5)(1,6)
    2	      assert.equal(16, curried_three_times(2,2))
    4	    end)
    4	    it("currying is fun!", function() 
    4	      local curried = functional.curry(function(a,b,c) return a .. b .. c end, 3)
    2	      local curried_twice = curried(1,2)
    2	      assert.equal('122', curried_twice(2,2))
    4	    end)
    4	    it("additional arguments get discarded", function() 
    4	      local curried = functional.curry(function(a,b,c) return a .. b .. c end, 5)
    2	      local curried_three_times = curried(1,2,5)
    2	      assert.equal('125', curried_three_times(2,2))
    4	    end)
    4	    it("varargs also can be curried", function() 
    2	      local curried = functional.curry(functional.zip, 3)
    2	      local once_called = curried({1,2,3})
    2	      assert.are_same({{1,1,1}, {2,2,2}, {3,3,3}}, once_called({1,2,3}, {1,2,3}))
    4	    end)
    4	  end)
     	  
    4	  describe("call_until facility", function() 
    4	    it("call_until returns first value satisfying predicate", function() 
   20	      assert.equal(10, functional.call_until(function(x) return x > 9 end, function(x) return x + 2 end, 2))
    4	    end)
    4	    it("call_until returns start value if it satisfies predicate", function() 
    4	      assert.equal(2, functional.call_until(function(x) return x < 10 end, function(x) return x + 2 end, 2))
    4	    end)
    4	  end)
     	  
    4	  describe("times facility", function()
    4	    it("0 times anything is empty table", function() 
    2	      assert.are.same({}, functional.times(0, {}))
    4	    end)
    4	    it("2 times empty table is table with two empty tables", function() 
    2	      assert.are.same({{},{}}, functional.times(2, {}))
    4	    end)
    4	    it("5 times 1 is table with five ones", function()
    2	      assert.are.same({1,1,1,1,1}, functional.times(5, 1))
    4	    end)
    4	  end)
     	  
    4	  describe("take facility", function()
    4	    it("if one element is taken first one is returned", function()
    4	      assert.are.same({1}, functional.take(1, function() return 1 end))
    4	    end)
    4	    it("if three elements are taken first three are returned", function()
    2	      local i = 0
    8	      assert.are.same({1,2,3}, functional.take(3, function() i = i+1; return i end))
    4	    end)
    4	    it("if five elements are taken first five are returned", function()
    2	      local i = ''
   12	      assert.are.same({'a', 'aa', 'aaa', 'aaaa', 'aaaaa'}, functional.take(5, function() i = i .. 'a'; return i end))
    4	    end)
    4	  end)
     	  
    4	  describe("drop facility", function()
    4	    it("if one element is taken iterator holds second one", function()
    6	      assert.equal(1, functional.drop(1, function() return 1 end)())
    4	    end)
    4	    it("if three elements are taken iterator holds fourth", function()
    2	      local i = 0
   10	      assert.equal(4, functional.drop(3, function() i = i+1; return i end)())
    4	    end)
    4	    it("if five elements are taken first five are returned", function()
    2	      local i = ''
   14	      assert.equal('aaaaaa', functional.drop(5, function() i = i .. 'a'; return i end)())
    4	    end)
    4	  end)
     	  
    4	  describe("range facility", function() 
    4	    it("5 elements stepping from 0 by 2 is 0, 2,4,6,8", function()
    2	      assert.are.same({0,2,4,6,8}, functional.range(5, 0, 2))
    4	    end)
    4	    it("5 elements stepping from 0 by -2 is 0, -2,-4,-6,-8", function()
    2	      assert.are.same({0,-2,-4,-6,-8}, functional.range(5, 0, -2))
    4	    end)
    4	  end)
     	  
    4	  describe("is_sequence facility", function()
    4	    it("empty table is a sequence", function()
    2	      assert.is_true(functional.is_sequence({}))
    4	    end)
    4	    it("nonempty sequential table is a sequence", function()
    2	      assert.is_true(functional.is_sequence({1,2,3,4,5,6,100}))
    4	    end)
    4	    it("associative table is not a sequence", function()
    2	      assert.is_false(functional.is_sequence({[{}] = 1, [function() end] = 2, [4] = 2, 1,2,3}))
    4	    end)
    4	  end)
     	  
    4	  describe("cycle facility", function() 
    4	    it("six first elements from cycle made out of two elements", function() 
    2	      assert.are.same({1,2,1,2,1,2}, functional.take(6, functional.cycle(1,2)))
    4	    end)
    4	    it("six first elements from cycle made out of five elements", function() 
    2	      assert.are.same({1,2,3,4,100,1}, functional.take(6, functional.cycle(1,2,3,4,100)))
    4	    end)
    4	  end)
     	  
    6	end)

==============================================================================
.\functional.lua
==============================================================================
     	
     	-- Functional programming facilities
     	-- Should be moved to a different module, when possible
     	
     	-- Accumulates value using function f on previous value of accumulator and current value.
     	-- f shall be associative and commutative, as order of execution is undefined in case of associative tables
     	-- in case of arrays it is linear
     	local function fold(tab, f, acc)
  376	  assert(type(tab) == 'table', "fold can be called only on tables")
 1696	  for k, v in pairs(tab) do
 1320	    acc = f(acc, v, k)
     	  end
  376	  return acc
     	end
     	
     	-- Returns table made by evaluating func on each element of cont
     	local function map(tab, func)
  654	  return fold(tab, function(acc, val, key) acc[key] = func(val, key); return acc end, {})
     	end
     	
     	-- returns two values: first is a table containing elements satisfying predicate, second is a table containing elements not satisfying predicate
     	local function partition(tab, pred)
   26	  assert(type(tab) == 'table', "only tables may be partitioned")
   52	  return unpack(fold(tab, function(acc, val, key) 
   94	      if pred(val, key) then acc[1][key] = val 
   46		  else acc[2][key] = val end 
  120		  return acc end, 
   52		{{},{}}))
     	end
     	
     	-- Returns table containing only elements, that satisfy given predicate
     	local function filter(tab, pred)
   18	  return (partition(tab, pred))
     	end
     	
     	-- Returns key of first element satifying predicate
     	local function first(tab, pred)
  140	  assert(type(tab) == 'table', "any can be called only on tables")
  340	  for k, v in pairs(tab) do
  280	    if pred(v, k) then return k end
     	  end
   60	  return nil
     	end
     	
     	-- Checks if all elements in a table satisfy a predicate
     	local function all(tab, pred)
   30	  assert(type(tab) == 'table', "all can be called only on tables")
  114	  return first(tab, function(v, k) return not pred(v, k) end) == nil
     	end
     	
     	-- Checks if any of elements in a table satisfy a predicate
     	local function any(tab, pred)
   88	  assert(type(tab) == 'table', "any can be called only on tables")
   88	  return first(tab, pred) ~= nil
     	end
     	
     	-- True if given table is empty, false otherwise
     	local function empty(tab)
   76	  return not any(tab, function() return true end)
     	end
     	
     	
     	-- Returns "some" element from the table
     	-- in sequences, it is first element, in associative arrays it can be any
     	local function head(tab)
    4	  assert(not empty(tab), "Empty table has no head")
    8	  return tab[first(tab, function() return true end)]
     	end
     	
     	-- Returns all elements from the table, except one (the one returned by 'head')
     	-- in sequences, it is first element, in associative arrays it can be any
     	-- it is a slow function, as it has to copy the whole table (lua does not offer table reuse without modifying it)
     	local function tail(tab)
    4	  assert(not empty(tab), "Empty table has no tail")
    8	  local head_val = tab[first(tab, function() return true end)]
    4	  local found = false -- in case this value appears more than once in a table
    8	  return filter(tab, function(x)
   14	    res = found or x ~= head_val 
   14		if not found and x == head_val then found = true end 
   14		return res 
    4		end)
     	end
     	
     	-- calls f for all elements in tab
     	local function forall(tab, f)
    8	  fold(tab, function(acc, v, k) f(v, k); return nil end, nil)
    2	  return nil
     	end
     	
     	-- Accumulates value using function f on previous value of accumulator and current value.
     	-- f shall be associative and commutative, as order of execution is undefined in case of associative tables
     	-- in case of arrays it is linear
     	-- Holds temporary results
     	local function scan(tab, f, acc)
   10	  assert(type(tab) == 'table', "scan can be called only on tables")
   10	  local result = {acc}
   34	  for _, v in pairs(tab) do
   24	    result[#result + 1] = f(result[#result], v, k)
     	  end
     	  
   10	  return result
     	end
     	
     	-- returns size of a table (counts also associative entries, unlike #tab)
     	local function sizeof(tab)
   52	  return fold(tab, function(acc, x) return acc+1 end, 0)
     	end
     	
     	-- Returns sum of a table
     	local function sum(tab)
   48	  return fold(tab, function(a, b) return a+b end, 0)
     	end
     	
     	-- Returns product of a table
     	local function product(tab)
   10	  return fold(tab, function(a, b) return a*b end, 1)
     	end
     	
     	-- Returns concatenated table
     	-- Don't use it for large (>100 kB) tables!
     	-- Don't use for associative tables! order of concatenation is then undefined
     	local function concatenate(tab)
   88	  return fold(tab, function(a, b) return a..b end, '')
     	end
     	
     	-- returns the biggest value in a table
     	local function maximum(tab)
    4	  assert(not empty(tab), "empty table does not have a maximum")
   24	  return fold(tab, function(a, b) return (a > b and a) or b end, tab[first(tab, function() return true end)])
     	end
     	
     	-- returns the smallest value in a table
     	local function minimum(tab)
    4	  assert(not empty(tab), "empty table does not have a maximum")
   24	  return fold(tab, function(a, b) return (a < b and a) or b end, tab[first(tab, function() return true end)])
     	end
     	
     	-- Merges unlimited amount of tables with given function
     	-- Results in one table made out of this function's results 
     	-- f is applied to a table
     	local function zip_with(f, ...)
   20	  assert(type(f) == 'function', "First argument to zip_with must be a function")
   20	  if ... == nil then return nil end
   18	  local input_tables = {...}
     	  
   76	  assert(all(input_tables, function(v) return type(v) == 'table' end), "Can zip only tables, for making single tables see pack")
   18	  local keys = {}
   18	  local output_tables = {}
     	  
   76	  for _, tab in pairs(input_tables) do
     	    -- no check for sizes, because it'd require traversing whole table each time
  192		for k, _ in pairs(tab) do
  134	      if not keys[k] then
  604	  	    output_tables[k] = f(map(input_tables, function(t) return t[k] end))
     		  end
     		end
     	  end
     	
   18	  return output_tables
     	end
     	
     	-- Merges unlimited amount of tables by keys
     	-- Results in one table made out of tuples
     	local function zip(...)
  120	  return zip_with(function(x) return x end, ...)
     	end
     	
     	-- Returns function that is a result of applying f1 to results of call to f2
     	-- f1 shall have only one argument
     	local function compose(f1, f2)
    4	  assert(type(f1) == type(f2) and type(f1) == 'function', "compose can be called only on functions")
   28	  return function(...) return f1(f2(...)) end
     	end
     	
     	-- true if table is a sequence - only consecutive positive integers starting from 0
     	local function is_sequence(tab)
   10	  if type(tab) ~= 'table' then return false end
   10	  return #tab == sizeof(tab)
     	end
     	
     	-- Flips order of arguments in function
     	-- f shall have only two arguments
     	local function flip(f)
   24	  assert(type(f) == 'function', "flip can be called only on function")
   56	  return function(x,y) return f(y,x) end
     	end
     	
     	-- extracts n arguments from a sequence args
     	-- args must be a sequence, but may have nils inside
     	-- returns it as n values
     	local function extract_args(n, args)
    6	  assert(type(n) == type(0) and n >= 0, "Count must be non-negative integer")
    6	  assert(type(args) == 'table', "Args must be a table")
     	  
     	  local function helper(n, k, args)
   32	    if k > n then 
    6	      return nil
     	    else 
   26	      return args[k], helper(n, k+1, args)
     	    end
     	  end
     	  
    6	  return helper(n, 1, args)
     	end
     	
     	-- Changes order of arguments to given in the sequence
     	-- second argument is a sequence of integers indicating which argument shall go in the place
     	local function flipall(f, seq)
    4	  assert(is_sequence(seq), "Argument order must be a sequence")
    4	  assert(type(f) == 'function', "Only function arguments may be flipped")
     	  
    4	  local arg_seq = seq
****0	  return function (...) 
    4	      local received_args = {...}
   20		  local ordered_args = fold(arg_seq, function(acc, v, k) acc[v] = received_args[k]; return acc end, {})
    4		  return f(extract_args(#arg_seq, ordered_args))
     	    end  
     	end
     	
     	-- Takes elements out of internal tables and put them into first level of tables (removes second level)
     	-- if key is present in more than one table, last of them is present in resulting table 
     	local function key_sensitive_flatten(input_tables)
    4	  assert(type(input_tables) == 'table', "Only table can be flattened")
    4	  local result = {}
   12	  for _, tab in pairs(input_tables) do
   22	    for k, t in pairs(tab) do
   14		  result[k] = t
     		end
     	  end
     	  
    4	  return result
     	end
     	
     	-- Takes elements out of all internal tables into ordered list
     	-- All elements will be present in this list, but order is not defined
     	local function key_insensitive_flatten(input_tables)
    4	  assert(type(input_tables) == 'table', "Only table can be flattened")
    4	  local result = {}
   18	  for _, tab in pairs(input_tables) do
   60	    fold(tab, function(acc, v) acc[#acc + 1] = v; return acc end, result)
     	  end
     	  
    4	  return result
     	end
     	
     	-- returns all keys of a given table
     	local function keys(tab)
    6	  assert(type(tab) == 'table', "Only table has keys")
   36	  return fold(tab, function(acc, v, k) acc[#acc + 1] = k; return acc end, {})
     	end
     	
     	-- returns all values of a given table
     	local function values(tab)
   10	  return fold(tab, function(acc, v) acc[#acc + 1] = v; return acc end, {})
     	end
     	
     	-- returns true if tab contains val, false otherwise
     	local function contains(tab, val)
   34	  assert(type(tab) == 'table', "Contains can be called only on tables")
  140	  return any(tab, function(x) return x == val end)
     	end
     	
     	-- returns true if values in tables are equal (number of occurrences counts)
     	local function are_values_equal(tab1, tab2)
   26	  assert(type(tab1) == 'table', "values can be compared on tables")
   26	  assert(type(tab2) == 'table', "values can be compared on tables")
     	
  160	  local tab = fold(tab1, function(acc, x) if acc[x] then acc[x] = acc[x] + 1 else acc[x] = 1 end return acc end, {})
  158	  return #fold(tab2, function(acc, x) if acc[x] then acc[x] = acc[x] - 1 else acc[x] = -1 end if acc[x] == 0 then acc[x] = nil end return acc end, tab) == 0
     	end
     	
     	-- Function currying, i.e. returns function that must be called with a total number of arguments equal to arg_count
     	-- but not necessarily in one shot, e.g. f1 = curry(f, 5); f2 = curried(2,4); f3 = f(2,5); value = f3(5)
     	local function curry(f, arg_count)
   28	  assert(type(f) == 'function', "only a function may be curried")
   28	  assert(arg_count > 0, "you may curry a function only for a positive number of arguments")
     	  
   28	  local tab = {}
     	  local function func(...)
  134	    tab = fold({...}, function(acc, x) acc[#acc + 1] = x; return acc end, tab)
   46		if #tab >= arg_count then
   28		  return f(unpack(tab))
     		else
   18		  return curry(func, arg_count - #tab)
     		end
     	  end
   28	  return func
     	end
     	
     	-- calls mutator on its results until predicate on the result is true
     	local function call_until(pred, mutator, start_val)
    4	  local val = start_val
   12	  while not pred(val) do
    8	    val = mutator(val)
     	  end
    4	  return val
     	end
     	
     	-- returns a sequence with requested number of values generated by func
     	local function take(n, func)
   26	  assert(type(n) == type(0), "count must be a number")
     	  local function take_helper(n, func)
  120	    if n <= 0 then return nil
   94		else return func(), take_helper(n - 1, func)
     		end
     	  end
     	  
   26	  return {take_helper(n, func)}  
     	end
     	
     	-- returns func after taking n elements from the front
     	local function drop(n, func)
    6	  assert(type(n) == type(0), "count must be a number")
    6	  take(n, func)
    6	  return func
     	end
     	
     	-- returns n numbers starting from begin incrementing with step
     	local function range(n, begin, step)
    4	  assert(type(n) == type(0), "count must be a number")
    4	  assert(type(begin) == type(0), "begin value must be a number")
    4	  assert(type(step) == type(0), "step must be a number")
    4	  local value = begin
   24	  return take(n, function() local res = value; value = value + step; return res end) 
     	end
     	
     	-- creates an iterator that returns given elements in cycle
     	local function cycle(...)
   10	  local pieces = {...}
   10	  assert(#pieces > 0, "to cycle must get more than one item")
     	  
   10	  local current = 1
     	  local function cycle_helper()
   38	    local res = pieces[current]
   38		if current == #pieces then 
   22		  current = 1
     		else 
   16		  current = current + 1
     		end
     		
   38		return (type(res) == 'function' and res()) or res	
     	  end
     	  
   10	  return cycle_helper
     	end
     	
     	-- returns a table with p replicated n times
     	local function times(n, p)
    6	  return take(n, cycle(p))
     	end
     	
    2	local functional = {
    2	  fold = fold,
    2	  map = map,
    2	  partition = partition,
    2	  filter = filter,
    2	  first = first,
    2	  all = all,
    2	  any = any,
    2	  empty = empty,
    2	  forall = forall,
    2	  head = head,
    2	  tail = tail,
    2	  scan = scan,
    2	  sizeof = sizeof,
    2	  sum = sum,
    2	  product = product,
    2	  concatenate = concatenate,
    2	  maximum = maximum,
    2	  minimum = minimum,
    2	  zip_with = zip_with,
    2	  zip = zip,
    2	  compose = compose,
    2	  flip = flip,
    2	  extract_args = extract_args,
    2	  flipall = flipall,
    2	  key_sensitive_flatten = key_sensitive_flatten, 
    2	  key_insensitive_flatten = key_insensitive_flatten,
    2	  keys = keys,
    2	  values = values,
    2	  contains = contains,
    2	  are_values_equal = are_values_equal,
    2	  curry = curry,
    2	  call_until = call_until,
    2	  times = times,
    2	  take = take,
    2	  drop = drop,
    2	  range = range,
    2	  is_sequence = is_sequence,
    2	  cycle = cycle
     	}
     	
    2	return functional

==============================================================================
E:\Lua\rocks\2.1\lua\luarocks\loader.lua
==============================================================================
     	
     	--- A module which installs a Lua package loader that is LuaRocks-aware.
     	-- This loader uses dependency information from the LuaRocks tree to load
     	-- correct versions of modules. It does this by constructing a "context"
     	-- table in the environment, which records which versions of packages were
     	-- used to load previous modules, so that the loader chooses versions
     	-- that are declared to be compatible with the ones loaded earlier.
****0	local loaders = package.loaders or package.searchers
     	local package, require, ipairs, pairs, table, type, next, tostring, error =
****0	      package, require, ipairs, pairs, table, type, next, tostring, error
****0	local unpack = unpack or table.unpack
     	
     	--module("luarocks.loader")
****0	local loader = {}
****0	package.loaded["luarocks.loader"] = loader
     	
****0	local path = require("luarocks.path")
****0	local manif_core = require("luarocks.manif_core")
****0	local deps = require("luarocks.deps")
****0	local cfg = require("luarocks.cfg")
     	
****0	loader.context = {}
     	
     	-- Contains a table when rocks trees are loaded,
     	-- or 'false' to indicate rocks trees failed to load.
     	-- 'nil' indicates rocks trees were not attempted to be loaded yet.
****0	loader.rocks_trees = nil
     	
     	local function load_rocks_trees() 
****0	   local any_ok = false
****0	   local trees = {}
****0	   for _, tree in ipairs(cfg.rocks_trees) do
****0	      local manifest, err = manif_core.load_local_manifest(path.rocks_dir(tree))
****0	      if manifest then
****0	         any_ok = true
****0	         table.insert(trees, {tree=tree, manifest=manifest})
     	      end
     	   end
****0	   if not any_ok then
****0	      loader.rocks_trees = false
****0	      return false
     	   end
****0	   loader.rocks_trees = trees
****0	   return true
     	end
     	
     	--- Process the dependencies of a package to determine its dependency
     	-- chain for loading modules.
     	-- @param name string: The name of an installed rock.
     	-- @param version string: The version of the rock, in string format
****0	function loader.add_context(name, version)
     	   -- assert(type(name) == "string")
     	   -- assert(type(version) == "string")
     	
    2	   if loader.context[name] then
    2	      return
     	   end
****0	   loader.context[name] = version
     	
****0	   if not loader.rocks_trees and not load_rocks_trees() then
****0	      return nil
     	   end
     	
****0	   for _, tree in ipairs(loader.rocks_trees) do
****0	      local manifest = tree.manifest
     	
     	      local pkgdeps
****0	      if manifest.dependencies and manifest.dependencies[name] then
****0	         pkgdeps = manifest.dependencies[name][version]
     	      end
****0	      if not pkgdeps then
****0	         return nil
     	      end
****0	      for _, dep in ipairs(pkgdeps) do
****0	         local pkg, constraints = dep.name, dep.constraints
     	   
****0	         for _, tree in ipairs(loader.rocks_trees) do
****0	            local entries = tree.manifest.repository[pkg]
****0	            if entries then
****0	               for version, pkgs in pairs(entries) do
****0	                  if (not constraints) or deps.match_constraints(deps.parse_version(version), constraints) then
****0	                     loader.add_context(pkg, version)
     	                  end
     	               end
     	            end
     	         end
     	      end
     	   end
     	end
     	
     	--- Internal sorting function.
     	-- @param a table: A provider table.
     	-- @param b table: Another provider table.
     	-- @return boolean: True if the version of a is greater than that of b.
     	local function sort_versions(a,b)
****0	   return a.version > b.version
     	end
     	
     	--- Request module to be loaded through other loaders,
     	-- once the proper name of the module has been determined.
     	-- For example, in case the module "socket.core" has been requested
     	-- to the LuaRocks loader and it determined based on context that
     	-- the version 2.0.2 needs to be loaded and it is not the current
     	-- version, the module requested for the other loaders will be
     	-- "socket.core_2_0_2".
     	-- @param module The module name requested by the user, such as "socket.core"
     	-- @param name The rock name, such as "luasocket"
     	-- @param version The rock version, such as "2.0.2-1"
     	-- @param module_name The actual module name, such as "socket.core" or "socket.core_2_0_2".
     	-- @return table or (nil, string): The module table as returned by some other loader,
     	-- or nil followed by an error message if no other loader managed to load the module.
     	local function call_other_loaders(module, name, version, module_name)
    6	   for i, a_loader in ipairs(loaders) do
    6	      if a_loader ~= loader.luarocks_loader then
    4	         local results = { a_loader(module_name) }
    4	         if type(results[1]) == "function" then
    2	            return unpack(results)
     	         end
     	      end
     	   end
****0	   return "Failed loading module "..module.." in LuaRocks rock "..name.." "..version
     	end
     	
     	--- Search for a module in the rocks trees
     	-- @param module string: module name (eg. "socket.core")
     	-- @param filter_module_name function(string, string, string, string, number):
     	-- a function that takes the module name (eg "socket.core"), the rock name
     	-- (eg "luasocket"), the version (eg "2.0.2-1"), the path of the rocks tree
     	-- (eg "/usr/local"), and the numeric index of the matching entry, so the
     	-- filter function can know if the matching module was the first entry or not.
     	-- @return string, string, string: name of the rock containing the module
     	-- (eg. "luasocket"), version of the rock (eg. "2.0.2-1"),
     	-- name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is
     	-- stored versioned).
     	local function select_module(module, filter_module_name)
     	   --assert(type(module) == "string")
     	   --assert(type(filter_module_name) == "function")
     	
    4	   if not loader.rocks_trees and not load_rocks_trees() then
****0	      return nil
     	   end
     	
    4	   local providers = {}
    6	   for _, tree in ipairs(loader.rocks_trees) do
    4	      local entries = tree.manifest.modules[module]
    4	      if entries then
    2	         for i, entry in ipairs(entries) do
    2	            local name, version = entry:match("^([^/]*)/(.*)$")
    2	            local module_name = tree.manifest.repository[name][version][1].modules[module]
    2	            if type(module_name) ~= "string" then
****0	               error("Invalid data in manifest file for module "..tostring(module).." (invalid data for "..tostring(name).." "..tostring(version)..")")
     	            end
    2	            module_name = filter_module_name(module_name, name, version, tree.tree, i)
    2	            if loader.context[name] == version then
    2	               return name, version, module_name
     	            end
****0	            version = deps.parse_version(version)
****0	            table.insert(providers, {name = name, version = version, module_name = module_name})
     	         end
     	      end
     	   end
     	
    2	   if next(providers) then
****0	      table.sort(providers, sort_versions)
****0	      local first = providers[1]
****0	      return first.name, first.version.string, first.module_name
     	   end
     	end
     	
     	--- Search for a module
     	-- @param module string: module name (eg. "socket.core")
     	-- @return string, string, string: name of the rock containing the module
     	-- (eg. "luasocket"), version of the rock (eg. "2.0.2-1"),
     	-- name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is
     	-- stored versioned).
     	local function pick_module(module)
****0	   return
    8	      select_module(module, function(module_name, name, version, tree, i)
    2	         if i > 1 then
****0	            module_name = path.versioned_name(module_name, "", name, version)
     	         end
    2	         module_name = path.path_to_module(module_name)
    2	         return module_name
    4	      end)
     	end
     	
     	--- Return the pathname of the file that would be loaded for a module.
     	-- @param module string: module name (eg. "socket.core")
     	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0	function loader.which(module)
****0	   local name, version, module_name = select_module(module, path.which_i)
****0	   return module_name
     	end
     	
     	--- Package loader for LuaRocks support.
     	-- A module is searched in installed rocks that match the
     	-- current LuaRocks context. If module is not part of the
     	-- context, or if a context has not yet been set, the module
     	-- in the package with the highest version is used.
     	-- @param module string: The module name, like in plain require().
     	-- @return table: The module table (typically), like in plain
     	-- require(). See <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
     	-- in the Lua reference manual for details.
****0	function loader.luarocks_loader(module)
    4	   local name, version, module_name = pick_module(module)
    4	   if not name then
    2	      return "No LuaRocks module found for "..module
     	   else
    2	      loader.add_context(name, version)
    2	      return call_other_loaders(module, name, version, module_name)
     	   end
     	end
     	
****0	table.insert(loaders, 1, loader.luarocks_loader)
     	
****0	return loader

==============================================================================
E:\Lua\rocks\2.1\lua\luarocks\path.lua
==============================================================================
     	
     	--- LuaRocks-specific path handling functions.
     	-- All paths are configured in this module, making it a single
     	-- point where the layout of the local installation is defined in LuaRocks.
     	--module("luarocks.path", package.seeall)
****0	local path = {}
     	
****0	local dir = require("luarocks.dir")
****0	local cfg = require("luarocks.cfg")
****0	local util = require("luarocks.util")
     	
     	--- Infer rockspec filename from a rock filename.
     	-- @param rock_name string: Pathname of a rock file.
     	-- @return string: Filename of the rockspec, without path.
****0	function path.rockspec_name_from_rock(rock_name)
****0	   assert(type(rock_name) == "string")
****0	   local base_name = dir.base_name(rock_name)
****0	   return base_name:match("(.*)%.[^.]*.rock") .. ".rockspec"
     	end
     	
****0	function path.rocks_dir(tree)
****0	   if type(tree) == "string" then
****0	      return dir.path(tree, cfg.rocks_subdir)
     	   else
****0	      assert(type(tree) == "table")
****0	      return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)
     	   end
     	end
     	
****0	function path.root_dir(rocks_dir)
****0	   assert(type(rocks_dir) == "string")
****0	   return rocks_dir:match("(.*)" .. util.matchquote(cfg.rocks_subdir) .. ".*$")
     	end
     	
****0	function path.rocks_tree_to_string(tree)
****0	   if type(tree) == "string" then
****0	      return tree
     	   else
****0	      assert(type(tree) == "table")
****0	      return tree.root
     	   end
     	end
     	
****0	function path.deploy_bin_dir(tree)
****0	   if type(tree) == "string" then
****0	      return dir.path(tree, "bin")
     	   else
****0	      assert(type(tree) == "table")
****0	      return tree.bin_dir or dir.path(tree.root, "bin")
     	   end
     	end
     	
****0	function path.deploy_lua_dir(tree)
****0	   if type(tree) == "string" then
****0	      return dir.path(tree, cfg.lua_modules_path)
     	   else
****0	      assert(type(tree) == "table")
****0	      return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
     	   end
     	end
     	
****0	function path.deploy_lib_dir(tree)
****0	   if type(tree) == "string" then
****0	      return dir.path(tree, cfg.lib_modules_path)
     	   else
****0	      assert(type(tree) == "table")
****0	      return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
     	   end
     	end
     	
****0	function path.manifest_file(tree)
****0	   if type(tree) == "string" then
****0	      return dir.path(tree, cfg.rocks_subdir, "manifest")
     	   else
****0	      assert(type(tree) == "table")
****0	      return (tree.rocks_dir and dir.path(tree.rocks_dir, "manifest")) or dir.path(tree.root, cfg.rocks_subdir, "manifest")
     	   end
     	end
     	
     	--- Get the directory for all versions of a package in a tree.
     	-- @param name string: The package name. 
     	-- @return string: The resulting path -- does not guarantee that
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- the package (and by extension, the path) exists.
****0	function path.versions_dir(name, tree)
****0	   assert(type(name) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name)
     	end
     	
     	--- Get the local installation directory (prefix) for a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.install_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version)
     	end
     	
     	--- Get the local filename of the rockspec of an installed rock.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the file) exists.
****0	function path.rockspec_file(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, name.."-"..version..".rockspec")
     	end
     	
     	--- Get the local filename of the rock_manifest file of an installed rock.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the file) exists.
****0	function path.rock_manifest_file(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "rock_manifest")
     	end
     	
     	--- Get the local installation directory for C libraries of a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.lib_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "lib")
     	end
     	
     	--- Get the local installation directory for Lua modules of a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.lua_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "lua")
     	end
     	
     	--- Get the local installation directory for documentation of a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.doc_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "doc")
     	end
     	
     	--- Get the local installation directory for configuration files of a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.conf_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "conf")
     	end
     	
     	--- Get the local installation directory for command-line scripts
     	-- of a package.
     	-- @param name string: The package name. 
     	-- @param version string: The package version.
     	-- @param tree string or nil: If given, specifies the local tree to use.
     	-- @return string: The resulting path -- does not guarantee that
     	-- the package (and by extension, the path) exists.
****0	function path.bin_dir(name, version, tree)
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   tree = tree or cfg.root_dir
****0	   return dir.path(path.rocks_dir(tree), name, version, "bin")
     	end
     	
     	--- Extract name, version and arch of a rock filename,
     	-- or name, version and "rockspec" from a rockspec name.
     	-- @param file_name string: pathname of a rock or rockspec
     	-- @return (string, string, string) or nil: name, version and arch
     	-- or nil if name could not be parsed
****0	function path.parse_name(file_name)
****0	   assert(type(file_name) == "string")
****0	   if file_name:match("%.rock$") then
****0	      return dir.base_name(file_name):match("(.*)-([^-]+-%d+)%.([^.]+)%.rock$")
     	   else
****0	      return dir.base_name(file_name):match("(.*)-([^-]+-%d+)%.(rockspec)")
     	   end
     	end
     	
     	--- Make a rockspec or rock URL.
     	-- @param pathname string: Base URL or pathname.
     	-- @param name string: Package name.
     	-- @param version string: Package version.
     	-- @param arch string: Architecture identifier, or "rockspec" or "installed".
     	-- @return string: A URL or pathname following LuaRocks naming conventions.
****0	function path.make_url(pathname, name, version, arch)
****0	   assert(type(pathname) == "string")
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
****0	   assert(type(arch) == "string")
     	
****0	   local filename = name.."-"..version
****0	   if arch == "installed" then
****0	      filename = dir.path(name, version, filename..".rockspec")
****0	   elseif arch == "rockspec" then
****0	      filename = filename..".rockspec"
     	   else
****0	      filename = filename.."."..arch..".rock"
     	   end
****0	   return dir.path(pathname, filename)
     	end
     	
     	--- Convert a pathname to a module identifier.
     	-- In Unix, for example, a path "foo/bar/baz.lua" is converted to
     	-- "foo.bar.baz"; "bla/init.lua" returns "bla"; "foo.so" returns "foo".
     	-- @param file string: Pathname of module
     	-- @return string: The module identifier, or nil if given path is
     	-- not a conformant module path (the function does not check if the
     	-- path actually exists).
****0	function path.path_to_module(file)
    2	   assert(type(file) == "string")
     	
    2	   local name = file:match("(.*)%."..cfg.lua_extension.."$")
    2	   if name then
    2	      name = name:gsub(dir.separator, ".")
    2	      local init = name:match("(.*)%.init$")
    2	      if init then
****0	         name = init
     	      end
     	   else
****0	      name = file:match("(.*)%."..cfg.lib_extension.."$")
****0	      if name then
****0	         name = name:gsub(dir.separator, ".")
     	      end
     	   end
    2	   if not name then name = file end
    2	   name = name:gsub("^%.+", ""):gsub("%.+$", "")
    2	   return name
     	end
     	
     	--- Obtain the directory name where a module should be stored.
     	-- For example, on Unix, "foo.bar.baz" will return "foo/bar".
     	-- @param mod string: A module name in Lua dot-separated format.
     	-- @return string: A directory name using the platform's separator.
****0	function path.module_to_path(mod)
****0	   assert(type(mod) == "string")
****0	   return (mod:gsub("[^.]*$", ""):gsub("%.", dir.separator))
     	end
     	
     	--- Set up path-related variables for a given rock.
     	-- Create a "variables" table in the rockspec table, containing
     	-- adjusted variables according to the configuration file.
     	-- @param rockspec table: The rockspec table.
****0	function path.configure_paths(rockspec)
****0	   assert(type(rockspec) == "table")
****0	   local vars = {}
****0	   for k,v in pairs(cfg.variables) do
****0	      vars[k] = v
     	   end
****0	   local name, version = rockspec.name, rockspec.version
****0	   vars.PREFIX = path.install_dir(name, version)
****0	   vars.LUADIR = path.lua_dir(name, version)
****0	   vars.LIBDIR = path.lib_dir(name, version)
****0	   vars.CONFDIR = path.conf_dir(name, version)
****0	   vars.BINDIR = path.bin_dir(name, version)
****0	   vars.DOCDIR = path.doc_dir(name, version)
****0	   rockspec.variables = vars
     	end
     	
     	--- Produce a versioned version of a filename.
     	-- @param file string: filename (must start with prefix)
     	-- @param prefix string: Path prefix for file
     	-- @param name string: Rock name
     	-- @param version string: Rock version
     	-- @return string: a pathname with the same directory parts and a versioned basename.
****0	function path.versioned_name(file, prefix, name, version)
****0	   assert(type(file) == "string")
****0	   assert(type(name) == "string")
****0	   assert(type(version) == "string")
     	
****0	   local rest = file:sub(#prefix+1):gsub("^/*", "")
****0	   local name_version = (name.."_"..version):gsub("%-", "_"):gsub("%.", "_")
****0	   return dir.path(prefix, name_version.."-"..rest)
     	end
     	
****0	function path.use_tree(tree)
****0	   cfg.root_dir = tree
****0	   cfg.rocks_dir = path.rocks_dir(tree)
****0	   cfg.deploy_bin_dir = path.deploy_bin_dir(tree)
****0	   cfg.deploy_lua_dir = path.deploy_lua_dir(tree)
****0	   cfg.deploy_lib_dir = path.deploy_lib_dir(tree)
     	end
     	
     	--- Apply a given function to the active rocks trees based on chosen dependency mode.
     	-- @param deps_mode string: Dependency mode: "one" for the current default tree,
     	-- "all" for all trees, "order" for all trees with priority >= the current default,
     	-- "none" for no trees (this function becomes a nop).
     	-- @param fn function: function to be applied, with the tree dir (string) as the first
     	-- argument and the remaining varargs of map_trees as the following arguments.
     	-- @return a table with all results of invocations of fn collected.
****0	function path.map_trees(deps_mode, fn, ...)
****0	   local result = {}
****0	   if deps_mode == "one" then
****0	      table.insert(result, (fn(cfg.root_dir, ...)) or 0)
****0	   elseif deps_mode == "all" or deps_mode == "order" then
****0	      local use = false
****0	      if deps_mode == "all" then
****0	         use = true
     	      end
****0	      for _, tree in ipairs(cfg.rocks_trees) do
****0	         if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(cfg.root_dir)) then
****0	            use = true
     	         end
****0	         if use then
****0	            table.insert(result, (fn(tree, ...)) or 0)
     	         end
     	      end
     	   end
****0	   return result
     	end
     	
     	--- Return the pathname of the file that would be loaded for a module, indexed.
     	-- @param module_name string: module name (eg. "socket.core")
     	-- @param name string: name of the package (eg. "luasocket")
     	-- @param version string: version number (eg. "2.0.2-1")
     	-- @param tree string: repository path (eg. "/usr/local")
     	-- @param i number: the index, 1 if version is the current default, > 1 otherwise.
     	-- This is done this way for use by select_module in luarocks.loader.
     	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0	function path.which_i(module_name, name, version, tree, i)
     	   local deploy_dir
****0	   if module_name:match("%.lua$") then
****0	      deploy_dir = path.deploy_lua_dir(tree)
****0	      module_name = dir.path(deploy_dir, module_name)
     	   else
****0	      deploy_dir = path.deploy_lib_dir(tree)
****0	      module_name = dir.path(deploy_dir, module_name)
     	   end
****0	   if i > 1 then
****0	      module_name = path.versioned_name(module_name, deploy_dir, name, version)
     	   end
****0	   return module_name
     	end
     	
     	--- Return the pathname of the file that would be loaded for a module, 
     	-- returning the versioned pathname if given version is not the default version
     	-- in the given manifest.
     	-- @param module_name string: module name (eg. "socket.core")
     	-- @param name string: name of the package (eg. "luasocket")
     	-- @param version string: version number (eg. "2.0.2-1")
     	-- @param tree string: repository path (eg. "/usr/local")
     	-- @param manifest table: the manifest table for the tree.
     	-- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0	function path.which(module_name, filename, name, version, tree, manifest)
****0	   local versions = manifest.modules[module_name]
****0	   assert(versions)
****0	   for i, name_version in ipairs(versions) do
****0	      if name_version == name.."/"..version then
****0	         return path.which_i(filename, name, version, tree, i):gsub("//", "/")
     	      end
     	   end
****0	   assert(false)
     	end
     	
****0	return path

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/busted\core.lua
==============================================================================
****0	local moon = require('busted.moon')
****0	local path = require('pl.path')
****0	local dir = require('pl.dir')
****0	local tablex = require('pl.tablex')
****0	local pretty = require('pl.pretty')
****0	local wrap_done = require('busted.done').new
     	
     	-- globals
****0	settimeout = nil
     	
     	-- exported module table
****0	local busted = {}
****0	busted._COPYRIGHT   = "Copyright (c) 2013 Olivine Labs, LLC."
****0	busted._DESCRIPTION = "A unit testing framework with a focus on being easy to use. http://www.olivinelabs.com/busted"
****0	busted._VERSION     = "Busted 1.10.0"
     	
     	-- set defaults
****0	busted.defaultoutput = path.is_windows and "plain_terminal" or "utf_terminal"
****0	busted.defaultpattern = '_spec'
****0	busted.defaultlua = 'luajit'
****0	busted.lpathprefix = "./src/?.lua;./src/?/?.lua;./src/?/init.lua"
****0	busted.cpathprefix = path.is_windows and "./csrc/?.dll;./csrc/?/?.dll;" or "./csrc/?.so;./csrc/?/?.so;"
****0	require('busted.languages.en')-- Load default language pack
     	
     	-- platform detection
     	local system, sayer_pre, sayer_post
****0	if pcall(require, 'ffi') then
****0	  system = require('ffi').os
****0	elseif path.is_windows then
****0	  system = 'Windows'
     	else
****0	  system = io.popen('uname -s'):read('*l')
     	end
     	
****0	if system == 'Linux' then
****0	  sayer_pre = 'espeak -s 160 '
****0	  sayer_post = ' > /dev/null 2>&1'
****0	elseif system and system:match('^Windows') then
****0	  sayer_pre = 'echo '
****0	  sayer_post = ' | ptts'
     	else
****0	  sayer_pre = 'say '
****0	  sayer_post = ''
     	end
****0	system = nil
     	
****0	local options = {}
     	local current_context
     	local test_is_async
     	local current_test_filename
     	
     	-- report a test-process error as a failed test
     	local internal_error = function(description, err)
****0	  local tag = ""
     	
****0	  if options.tags and #options.tags > 0 then
     	    -- tags specified; must insert a tag to make sure the error gets displayed
****0	    tag = " #"..options.tags[1]
     	  end
     	
****0	  if not current_context then
****0	    busted.reset()
     	  end
     	
****0	  busted.describe("Busted process errors occured" .. tag, function()
****0	    busted.it(description .. tag, function()
****0	      error(err)
****0	    end)
****0	  end)
     	end
     	
     	-- returns current time in seconds
****0	busted.gettime = os.clock
****0	if pcall(require, "socket") then
****0	  busted.gettime = package.loaded["socket"].gettime
     	end
     	
     	local language = function(lang)
    2	  if lang then
    2	    busted.messages = require('busted.languages.'..lang)
    2	    require('luassert.languages.'..lang)
     	  end
     	end
     	
     	-- load the outputter as set in the options, revert to default if it fails
     	local getoutputter  -- define first to enable recursion
     	getoutputter = function(output, opath, default)
     	  local success, out, f
    2	  if output:match(".lua$") then
     	    f = function()
****0	      return loadfile(path.normpath(path.join(opath, output)))()
     	    end
     	  else
     	    f = function()
    2	      return require('busted.output.'..output)()
     	    end
     	  end
     	
    2	  success, out = pcall(f)
     	
    2	  if not success then
****0	    if not default then
     	      -- even default failed, so error out the hard way
****0	      return error("Failed to open the busted default output; " .. tostring(output) .. ".\n"..out)
     	    else
****0	      internal_error("Unable to open output module; requested option '--output=" .. tostring(output).."'.", out)
     	      -- retry with default outputter
****0	      return getoutputter(default, opath)
     	    end
     	  end
    2	  return out
     	end
     	
     	-- acquire set of test files from the options specified
     	local gettestfiles = function(root_file, pattern)
     	  local filelist
     	
    2	  if path.isfile(root_file) then
****0	    filelist = { root_file }
    2	  elseif path.isdir(root_file) then
    2	    local pattern = pattern ~= "" and pattern or busted.defaultpattern
    2	    filelist = dir.getallfiles(root_file)
     	
    4	    filelist = tablex.filter(filelist, function(filename)
    7	      return path.basename(filename):find(pattern)
    4	    end)
     	
    4	    filelist = tablex.filter(filelist, function(filename)
    2	      if path.is_windows then
    2	        return not filename:find('%\\%.%w+.%w+')
     	      else
****0	        return not filename:find('/%.%w+.%w+')
     	      end
    4	    end)
     	  else
****0	    filelist = {}
     	  end
     	
    2	  return filelist
     	end
     	
     	local is_terra = function(fname)
    2	  return fname:find(".t", #fname-2, true) and true or false
     	end
     	
     	-- runs a testfile, loading its tests
     	local load_testfile = function(filename)
    2	  current_test_filename = filename
    2	  local old_TEST = _TEST
    2	  _TEST = busted._VERSION
     	
    4	  local success, err = pcall(function() 
     	    local chunk,err
    2	    if moon.is_moon(filename) then
****0	      if moon.has_moon then
****0	        chunk,err = moon.loadfile(filename)
     	      else
     	        chunk = function()
****0	          busted.describe("Moon script not installed", function()
****0	            busted.pending("File not tested because 'moonscript' isn't installed; "..tostring(filename))
****0	          end)
     	        end
     	      end
    2	    elseif is_terra(filename) then
****0	      if terralib then
****0	        chunk,err = terralib.loadfile(filename)
     	      else
     	        chunk = function()
****0	          busted.describe("Not running tests under Terra", function()
****0	            pending("File not tested because tests are not being run with 'terra'; "..tostring(filename))
****0	          end)
     	        end
     	      end
     	    else
    2	      chunk,err = loadfile(filename)
     	    end
     	    
    2	    if not chunk then
****0	      error(err,2)
     	    end
    2	    chunk()
    4	  end)
     	
    2	  if not success then
****0	    internal_error("Failed executing testfile; " .. tostring(filename), err)
     	  end
     	
    2	  _TEST = old_TEST
     	end
     	
     	local play_sound = function(failures)
****0	  if busted.messages.failure_messages and #busted.messages.failure_messages > 0 and
****0	    busted.messages.success_messages and #busted.messages.success_messages > 0 then
     	
****0	    math.randomseed(os.time())
     	
****0	    if failures and failures > 0 then
****0	      io.popen(sayer_pre.."\""..busted.messages.failure_messages[math.random(1, #busted.messages.failure_messages)]:format(failures).."\""..sayer_post)
     	    else
****0	      io.popen(sayer_pre.."\""..busted.messages.success_messages[math.random(1, #busted.messages.success_messages)].."\""..sayer_post)
     	    end
     	  end
     	end
     	
     	local get_fname = function(short_src)
  232	  return short_src:match('%"(.-)%"') -- matches first string within double quotes
     	end
     	
     	--=============================
     	-- Test engine
     	--=============================
     	
****0	local suite = {
     	  tests = {},       -- list holding all tests
     	  done = {},        -- list (boolean) indicating test was completed (either succesful or failed)
     	  started = {},     -- list (boolean) indicating test was started
     	  test_index = 1,
****0	  loop = require('busted.loop.default')
     	}
     	
     	-- execute a list of steps (functions)
     	-- each step gets a callback parameter to commence to the next step
     	busted.step = function(...)
  464	  local steps = { ... }
  464	  if #steps == 1 and type(steps[1]) == 'table' then
  464	    steps = steps[1]
     	  end
     	
  464	  local i = 0
     	
     	  local do_next
     	  do_next = function()
  932	    i = i + 1
  932	    if steps[i] then 
  700	      return steps[i](do_next) -- tail call to preserve stackspace
     	    end
     	  end
     	
  464	  do_next()
     	end
     	
     	-- Required to use on async callbacks. So busted can catch any errors and mark test as failed
     	busted.async = function(f)
****0	  test_is_async = true
****0	  if not f then
     	    -- this allows async() to be called on its own to mark any test as async.
****0	    return
     	  end
****0	  local test = suite.tests[suite.test_index]
     	
     	  local safef = function(...)
****0	    local result = { suite.loop.pcall(f, ...) }
     	
****0	    if result[1] then
****0	      return unpack(result, 2)
     	    else
****0	      local err = result[2]
****0	      if type(err) == "table" then
****0	        err = pretty.write(err)
     	      end
     	
****0	      local stack_trace = debug.traceback("", 2)
****0	      err, stack_trace = moon.rewrite_traceback(err, stack_trace)
     	
****0	      test.status.type = 'failure'
****0	      test.status.trace = stack_trace
****0	      test.status.err = err
     	-- TODO: line below tests 'test.done' to be function, but done may also be a table, callable. Yet no tests failed...      
****0	      assert(type(test.done) == 'function', 'non-test step failed (before/after/etc.):\n'..err)
****0	      test.done()
     	    end
     	  end
     	
****0	  return safef
     	end
     	
     	local match_tags = function(testName)
  232	  if #options.tags > 0 then
     	
****0	    for t = 1, #options.tags do
****0	      if testName:find(options.tags[t]) then
****0	        return true
     	      end
     	    end
     	
****0	    return false
     	  else
     	    -- default to true if no tags are set
  232	    return true
     	  end
     	end
     	
     	local match_excluded_tags = function(testName)
  232	  if #options.excluded_tags > 0 then
     	
****0	    for t = 1, #options.excluded_tags do
****0	      if testName:find(options.excluded_tags[t]) then
****0	        return true
     	      end
     	    end
     	
     	  end
     	
     	  -- By default we return false so that Busted will not exclude a test
     	  -- unless explicitly told to do so.
  232	  return false
     	end
     	
     	-- wraps test callbacks (it, for_each, setup, etc.) to ensure that sync
     	-- tests also call the `done` callback to mark the test/step as complete
     	local syncwrapper = function(f)
****0	  return function(done, ...)
  236	    test_is_async = nil
  236	    f(done, ...)
  236	    if not test_is_async then
     	      -- async function wasn't called, so it is a sync test/function
     	      -- hence must call it ourselves
  236	      done()
     	    end
     	  end
     	end
     	
     	local next_test
     	
     	next_test = function()
  234	  if #suite.done == #suite.tests     then return end  -- suite is complete
  232	  if suite.started[suite.test_index] then return end  -- current test already started
     	    
  232	  suite.started[suite.test_index] = true
     	
  232	  local this_test = suite.tests[suite.test_index]
  232	  this_test.index = suite.test_index
     	  
     	
  232	  assert(this_test, this_test.index..debug.traceback('', 1))
     	
  232	  local steps = {}
     	
     	  local execute_test = function(do_next)
     	    local timer
     	    local finally_callback
     	
     	    finally = function(f)
****0	      finally_callback = f
     	    end
     	
     	    local done = function()
  232	      if timer then
****0	        timer:stop()
****0	        timer = nil
     	      end
  232	      if this_test.done_trace then
****0	        if this_test.status.err == nil then
****0	          local stack_trace = debug.traceback("", 2)
****0	          err, stack_trace = moon.rewrite_traceback(err, stack_trace)
     	
****0	          this_test.status.err = 'test already "done":"'..this_test.name..'"'
****0	          this_test.status.err = this_test.status.err..'. First called from '..this_test.done_trace
****0	          this_test.status.type = 'failure'
****0	          this_test.status.trace = stack_trace
     	        end
****0	        return
     	      end
     	
  232	      assert(this_test.index <= #suite.tests, 'invalid test index: '..this_test.index)
     	
  232	      suite.done[this_test.index] = true
     	      -- keep done trace for easier error location when called multiple times
  232	      local done_trace = debug.traceback("", 2)
  232	      local err, done_trace = moon.rewrite_traceback(nil, done_trace)
     	
  232	      this_test.done_trace = pretty.write(done_trace)
     	
  232	      if not options.defer_print then
  232	        busted.output.currently_executing(this_test.status, options)
     	      end
     	
  232	      this_test.context:decrement_test_count()
  232	      if finally_callback then
****0	 	      finally_callback()
****0		      finally_callback = nil
     	      end
  232	      do_next()
     	    end
     	
  232	    if suite.loop.create_timer then
     	--TODO: global `settimeout` is created for an `it()` test, but never deleted, so it remains in the global namespace
     	--TODO: timeouts should also be available for before/after/before_each/after_each      
     	      settimeout = function(timeout)
****0	        if not timer then
****0	          timer = suite.loop.create_timer(timeout,function()
****0	            if not this_test.done_trace then
****0	              this_test.status.type = 'failure'
****0	              this_test.status.trace = ''
****0	              this_test.status.err = 'test timeout elapsed ('..timeout..'s)'
****0	              done()
     	            end
****0	          end)
     	        end
     	      end
     	    else
****0	      settimeout = nil
     	    end
     	
  232	    this_test.done = done
     	
     	    local trace
  464	    local ok, err = xpcall(
     	      function()
  232	        this_test.f(wrap_done(done))
     	      end,
     	      function(err)
****0	        trace = debug.traceback("", 2)
****0	        return err
  232	      end)
  232	    if ok then
     	      -- test returned, set default timer if one hasn't been set already
  232	      if settimeout and not timer and not this_test.done_trace then
     	--TODO: parametrize constant!
****0	        settimeout(1.0)
     	      end
     	    else
****0	      if type(err) == "table" then
****0	        err = pretty.write(err)
     	      end
     	
     	      -- remove all frames after the last frame found in the test file
****0	      local lines = {}
****0	      local j = 0
****0	      local last_j = nil
****0	      for line in trace:gmatch("[^\r\n]+") do
****0	        j = j + 1
****0	        lines[j] = line
****0	        local fname, lineno = line:match('%s+([^:]+):(%d+):')
****0	        if fname == current_test_filename then
****0	          last_j = j
     	        end
     	      end
****0	      trace = table.concat(lines, trace:match("[\r\n]+"), 1, last_j)
     	
****0	      err, trace = moon.rewrite_traceback(err, trace)
     	
****0	      this_test.status.type = 'failure'
****0	      this_test.status.trace = trace
****0	      this_test.status.err = err
****0	      done()
     	    end
     	  end
     	
     	  local check_before = function(context)
  696	    if context.before then
     	      local execute_before = function(do_next)
    4	        context.before(wrap_done(
     	          function()
    2	            context.before = nil
    2	            do_next()
    4	          end))
     	      end
     	
    2	      table.insert(steps, execute_before)
     	    end
     	  end
     	
  232	  local parents = this_test.context.parents
     	
  696	  for p=1, #parents do
  464	    check_before(parents[p])
     	  end
     	
  232	  check_before(this_test.context)
     	
  696	  for p=1, #parents do
  464	    if parents[p].before_each then
****0	      table.insert(steps, parents[p].before_each)
     	    end
     	  end
     	
  232	  if this_test.context.before_each then
****0	    table.insert(steps, this_test.context.before_each)
     	  end
     	
  232	  table.insert(steps, execute_test)
     	
  232	  if this_test.context.after_each then
****0	    table.insert(steps, this_test.context.after_each)
     	  end
     	
     	  local post_test = function(do_next)
  232	    local post_steps = {}
     	
     	    local check_after = function(context)
  696	      if context.after then
  232	        if context:all_tests_done() then
     	          local execute_after = function(do_next)
    4	            context.after(wrap_done(
     	              function()
    2	                context.after = nil
    2	                do_next()
    4	              end))
     	          end
     	
    2	          table.insert(post_steps, execute_after)
     	        end
     	      end
     	    end
     	
  696	    for p=#parents, 1, -1 do
  464	      if parents[p].after_each then
****0	        table.insert(post_steps, parents[p].after_each)
     	      end
     	    end
     	
  232	    check_after(this_test.context)
     	
  696	    for p=#parents, 1, -1 do
  464	      check_after(parents[p])
     	    end
     	
     	    local forward = function(do_next)
  232	      suite.test_index = suite.test_index + 1
  232	      next_test()
  232	      do_next()
     	    end
     	
  232	    table.insert(post_steps, forward)
  232	    busted.step(post_steps)
     	  end
     	
  232	  table.insert(steps, post_test)
  232	  busted.step(steps)
     	end
     	
     	local create_context = function(desc)
   76	  return {
   76	    desc = desc,
   76	    parents = {},
   76	    test_count = 0,
     	    increment_test_count = function(self)
  232	      self.test_count = self.test_count + 1
  696	      for _, parent in ipairs(self.parents) do
  464	        parent.test_count = parent.test_count + 1
     	      end
     	    end,
     	
     	    decrement_test_count = function(self)
  232	      self.test_count = self.test_count - 1
  696	      for _, parent in ipairs(self.parents) do
  464	        parent.test_count = parent.test_count - 1
     	      end
     	    end,
     	
     	    all_tests_done = function(self)
  232	      return self.test_count == 0
     	    end,
     	
     	    add_parent = function(self, parent)
  146	      table.insert(self.parents, parent)
  146	      if parent.desc ~= "" then
   72	        self.desc = parent.desc .. " / " .. self.desc
     	      end
     	    end
   76	  }
     	end
     	
     	
     	busted.describe = function(desc, more)
   74	  local context = create_context(desc)
     	
  146	  for _, parent in ipairs(current_context.parents) do
   72	    context:add_parent(parent)
     	  end
     	
   74	  context:add_parent(current_context)
     	
   74	  local old_context = current_context
     	
   74	  current_context = context
   74	  more()
     	
   74	  current_context = old_context
     	end
     	
     	busted.setup = function(before_func)
    2	  assert(type(before_func) == "function", "Expected function, got "..type(before_func))
    2	  current_context.before = syncwrapper(before_func)
     	end
     	
     	busted.before_each = function(before_func)
****0	  assert(type(before_func) == "function", "Expected function, got "..type(before_func))
****0	  current_context.before_each = syncwrapper(before_func)
     	end
     	
     	busted.teardown = function(after_func)
    2	  assert(type(after_func) == "function", "Expected function, got "..type(after_func))
    2	  current_context.after = syncwrapper(after_func)
     	end
     	
     	busted.after_each = function(after_func)
****0	  assert(type(after_func) == "function", "Expected function, got "..type(after_func))
****0	  current_context.after_each = syncwrapper(after_func)
     	end
     	
     	local function buildInfo(debug_info)
  232	  local info = {
  232	    source = debug_info.source,
  232	    short_src = debug_info.short_src,
  232	    linedefined = debug_info.linedefined,
     	  }
     	
  232	  local fname = get_fname(info.short_src)
     	
  232	  if fname and moon.is_moon(fname) then
****0	    info.linedefined = moon.rewrite_linenumber(fname, info.linedefined) or info.linedefined
     	  end
     	
  232	  return info
     	end
     	
     	busted.pending = function(name)
****0	  local test = {
     	    context = current_context,
****0	    name = current_context.desc .. " / " .. name
     	  }
     	
****0	  if match_excluded_tags(test.name) then
****0	    return
     	  end
     	
****0	  test.context:increment_test_count()
     	
****0	  local debug_info = debug.getinfo(2)
****0	  test.f = syncwrapper(function() end)
     	
****0	  test.status = {
     	    description = test.name,
     	    type = 'pending',
****0	    info = buildInfo(debug_info)
     	  }
     	
****0	  if match_tags(test.name) then
****0	    table.insert(suite.tests, test)
     	  end
     	end
     	
     	busted.it = function(name, test_func)
  232	  assert(type(test_func) == "function", "Expected function, got "..type(test_func))
     	
  232	  local test = {
  232	    context = current_context,
  232	    name = current_context.desc .. " / " .. name
     	  }
     	
  232	  if match_excluded_tags(test.name) then
****0	    return
     	  end
     	
  232	  test.context:increment_test_count()
     	
  232	  local debug_info = debug.getinfo(test_func)
  232	  test.f = syncwrapper(test_func)
     	
  232	  test.status = {
  232	    description = test.name,
  232	    type = 'success',
  232	    info = buildInfo(debug_info)
  232	  }
     	
  232	  if match_tags(test.name) then
  232	    table.insert(suite.tests, test)
     	  end
     	end
     	
     	busted.reset = function()
    2	  current_context = create_context('')
     	
    2	  suite = {
    2	    tests = {},
    2	    done = {},
    2	    started = {},
    2	    test_index = 1,
    2	    loop = require('busted.loop.default')
    2	  }
     	
    2	  busted.output = busted.output_reset
     	end
     	
     	busted.setloop = function(loop)
****0	  if type(loop) == 'string' then
****0	     suite.loop = require('busted.loop.'..loop)
     	  else
****0	     assert(loop.step)
****0	     suite.loop = loop
     	  end
     	end
     	
     	busted.run_internal_test = function(describe_tests)
****0	  local suite_bak = suite
****0	  local output_bak = busted.output
****0	  local current_context_bak = current_context
****0	  busted.reset()
     	
****0	  busted.output = require 'busted.output.stub'()
****0	  suite = {
     	    tests = {},
     	    done = {},
     	    started = {},
     	    test_index = 1,
****0	    loop = require('busted.loop.default')
     	  }
     	
****0	  if type(describe_tests) == 'function' then
****0	     describe_tests()
     	  else
****0	     load_testfile(describe_tests)
     	  end
     	
     	  repeat
****0	    next_test()
****0	    suite.loop.step()
****0	  until #suite.done == #suite.tests
     	
****0	  local statuses = {}
     	
****0	  for _, test in ipairs(suite.tests) do
****0	    table.insert(statuses, test.status)
     	  end
     	
****0	  suite = suite_bak
****0	  current_context = current_context_bak
****0	  busted.output = output_bak
     	
****0	  return statuses
     	end
     	
     	-- test runner
     	busted.run = function(got_options)
    2	  options = got_options
     	
    2	  language(options.lang)
    2	  busted.output = getoutputter(options.output, options.fpath, busted.defaultoutput)
    2	  busted.output_reset = busted.output  -- store in case we need a reset
     	  -- if no filelist given, get them
    2	  options.filelist = options.filelist or gettestfiles(options.root_file, options.pattern)
     	  -- load testfiles
     	
    2	  local ms = busted.gettime()
     	
    2	  local statuses = {}
    2	  local failures = 0
    2	  local suites = {}
    2	  local tests = 0
     	
     	  local function run_suite(s)
    2	    local old_TEST = _TEST
    2	    _TEST = busted._VERSION
     	    
    2	    suite = s
     	    repeat
    2	      next_test()
    2	      suite.loop.step()
    2	    until #suite.done == #suite.tests
     	    
    2	    _TEST = old_TEST
     	
  234	    for _, test in ipairs(suite.tests) do
  232	      table.insert(statuses, test.status)
  232	      if test.status.type == 'failure' then
****0	        failures = failures + 1
     	      end
     	    end
     	  end
     	
     	  -- there's already a test! probably an error
    2	  if #suite.tests > 0 then
****0	    run_suite(suite)
     	  end
     	
    4	  for i, filename in ipairs(options.filelist) do
    2	    busted.reset()
    2	    load_testfile(filename)
    2	    tests = tests + #suite.tests
    2	    suites[i] = suite
     	  end
     	
    2	  if not options.defer_print then
    2	    print(busted.output.header('global', tests))
     	  end
     	
    4	  for _, s in ipairs(suites) do
    2	    run_suite(s)
     	  end
     	
     	  --final run time
    2	  ms = busted.gettime() - ms
     	
    2	  local status_string = busted.output.formatted_status(statuses, options, ms)
     	
    2	  if options.sound then
****0	    play_sound(failures)
     	  end
     	
    2	  if tests == 0 then failures = 1 end -- no tests found, so exitcode should be non-zero
    2	  return status_string, failures
     	end
     	
****0	return setmetatable(busted, {
     	  __call = function(self, ...)
    2	    return busted.run(...)
     	  end
     	 })
     	

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/busted\done.lua
==============================================================================
****0	local M = {}
     	
     	-- adds tokens to the current wait list, does not change order/unordered
     	M.wait = function(self, ...)
****0	  local tlist = { ... }
****0	  for _, token in ipairs(tlist) do
****0	    if type(token) ~= "string" then
****0	      error("Wait tokens must be strings. Got "..type(token), 2)
     	    end
****0	    table.insert(self.tokens, token)
     	  end
     	end
     	
     	-- set list as unordered, adds tokens to current wait list
     	M.wait_unordered = function(self, ...)
****0	  self.ordered = false
****0	  self:wait(...)
     	end
     	
     	-- set list as ordered, adds tokens to current wait list
     	M.wait_ordered = function(self, ...)
****0	  self.ordered = true
****0	  self:wait(...)
     	end
     	
     	-- generates a message listing tokens received/open
     	M.tokenlist = function(self)
     	  local list
****0	  if #self.tokens_done == 0 then
****0	    list = "No tokens received."
     	  else
****0	    list = "Tokens received ("..tostring(#self.tokens_done)..")"
****0	    local s = ": "
****0	    for _,t in ipairs(self.tokens_done) do
****0	      list = list .. s .. "'"..t.."'"
****0	      s = ", "
     	    end
****0	    list = list .. "."
     	  end
****0	  if #self.tokens == 0 then
****0	    list = list .. " No more tokens expected."
     	  else
****0	    list = list .. " Tokens not received ("..tostring(#self.tokens)..")"
****0	    local s = ": "
****0	    for _, t in ipairs(self.tokens) do
****0	      list = list .. s .. "'"..t.."'"
****0	      s = ", "
     	    end
****0	    list = list .. "."
     	  end
****0	  return list
     	end
     	
     	-- marks a token as completed, checks for ordered/unordered, checks for completeness
****0	M.done = function(self, ...) self:_done(...) end  -- extra wrapper for same error level constant as __call method
     	M._done = function(self, token)
  236	  if token then
****0	    if type(token) ~= "string" then
****0	      error("Wait tokens must be strings. Got "..type(token), 3)
     	    end
****0	    if self.ordered then
****0	      if self.tokens[1] == token then
****0	        table.remove(self.tokens, 1)
****0	        table.insert(self.tokens_done, token)
     	      else
****0	        if self.tokens[1] then
****0	          error(("Bad token, expected '%s' got '%s'. %s"):format(self.tokens[1], token, self:tokenlist()), 3)
     	        else
****0	          error(("Bad token (no more tokens expected) got '%s'. %s"):format(token, self:tokenlist()), 3)
     	        end
     	      end
     	    else
     	      -- unordered
****0	      for i, t in ipairs(self.tokens) do
****0	        if t == token then
****0	          table.remove(self.tokens, i)
****0	          table.insert(self.tokens_done, token)
****0	          token = nil
     	          break
     	        end
     	      end
****0	      if token then
****0	        error(("Unknown token '%s'. %s"):format(token, self:tokenlist()), 3)
     	      end
     	    end
     	  end
  236	  if not next(self.tokens) then
     	    -- no more tokens, so we're really done...
  236	    self.done_cb()
     	  end
     	end
     	
     	
     	-- wraps a done callback into a done-object supporting tokens to sign-off
     	M.new = function(done_callback)
  236	  local obj = {
  236	    tokens = {},
  236	    tokens_done = {},
  236	    done_cb = done_callback,
  236	    ordered = true,  -- default for sign off of tokens
     	  }
  472	  return setmetatable( obj, {
     	      __call = function(self, ...)
  236	        self:_done(...)
     	      end,
  236	      __index = M,
  236	    })
     	end
     	
****0	return M

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/busted\loop\default.lua
==============================================================================
     	local busted 
****0	local loop = {}
****0	local timers = {}
     	
     	-- the timers implemented here will not be useful within the 
     	-- context of the 'default' loop (this file). But they can be used
     	-- in combination with coroutine schedulers, see 'busted.loop.copas.lua'
     	-- for an example of how the timer code here can be reused.
     	
     	local checktimers = function()
    2	  local now = busted.gettime()
    2	  for _,t in pairs(timers) do
****0	    if now > t.timeout then
****0	      t.on_timeout()
****0	      t:stop()
     	    end
     	  end
     	end
     	
     	loop.create_timer = function(secs,on_timeout)
****0	  busted = busted or require("busted")  -- lazy-load to prevent 'require-loop'
****0	  local timer = {
     	    timeout = busted.gettime() + secs,
     	    on_timeout = on_timeout,
     	    stop = function(self)
****0	      timers[self] = nil
     	    end,
     	  }
****0	  timers[timer] = timer
****0	  return timer
     	end
     	
     	loop.step = function()
    2	  busted = busted or require("busted")  -- lazy-load to prevent 'require-loop'
    2	  checktimers()
     	end
     	
****0	loop.pcall = pcall
     	
****0	return loop

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/busted\moon.lua
==============================================================================
****0	local success, ms = pcall(function() return require("moonscript") end)
     	
     	local is_moon = function(fname)
    2	  return fname:find(".moon", #fname-6, true) and true or false
     	end
     	
****0	if not success then
****0	  return {
     	    has_moon = false,
     	    is_moon = is_moon,
     	    loadfile = loadfile,
  232	    rewrite_traceback = function(err, trace) return err, trace end
     	  }
     	end
     	
****0	local util = require("moonscript.util")
****0	local line_tables = require("moonscript.line_tables")
****0	local table = require("table")
     	
****0	local _cache = {}
     	
     	-- find the line number of `pos` chars into fname
     	local lookup_line = function(fname, pos)
****0	  if not _cache[fname] then
****0	    local f = io.open(fname)
****0	    _cache[fname] = f:read("*a")
****0	    f:close()
     	  end
****0	  return util.pos_to_line(_cache[fname], pos)
     	end
     	
     	local rewrite_linenumber = function(fname, lineno)
****0	  local tbl = line_tables[fname]  
****0	  if fname and tbl then    
****0	    for i = lineno,0,-1 do
****0	      if tbl[i] then
****0	        return lookup_line(fname, tbl[i])
     	      end
     	    end
     	  end
     	end
     	
     	local rewrite_traceback = function(err, trace)
****0	  local lines = {}
****0	  local j = 0
     	
     	  local rewrite_one = function(line)
****0	    if line == nil then
****0	      return ""
     	    end
     	
****0	    local fname, lineno = line:match('[^"]+"([^:]+)".:(%d+):')
     	
****0	    if fname and lineno then
****0	      local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
****0	      if new_lineno then
****0	        line = line:gsub(':' .. lineno .. ':', ':' .. new_lineno .. ':')
     	      end
     	    end
****0	    return line
     	  end
     	
****0	  for line in trace:gmatch("[^\r\n]+") do
****0	    j = j + 1
****0	    lines[j] = rewrite_one(line)
     	  end
     	
****0	  return rewrite_one(err), table.concat(lines, trace:match("[\r\n]+"))
     	end
     	
****0	return {
     	    loadfile=ms.loadfile,
     	    has_moon=true,
     	    is_moon=is_moon,
     	    rewrite_linenumber=rewrite_linenumber,
****0	    rewrite_traceback=rewrite_traceback
     	}

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/busted\output\plain_terminal.lua
==============================================================================
     	--interface:
     	--  output.short_status
     	--  output.descriptive_status
     	--  output.currently_executing
     	
    2	local s = require 'say'
     	
     	local output = function()
     	  local pending_description = function(status, options)
****0	    return "\n\n"..s('output.pending')..": "..
****0	    status.info.short_src.." @ "..
****0	    status.info.linedefined..
****0	    "\n"..status.description
     	  end
     	
     	  local error_description = function(status, options)
****0	    return "\n\n"..s('output.failure')..": "..
****0	           status.info.short_src.." @ "..
****0	           status.info.linedefined..
****0	           "\n"..status.description..
****0	           "\n"..status.err
     	  end
     	
     	  local success_string = function()
  464	    return "+"
     	  end
     	
     	  local failure_string = function()
****0	    return "x"
     	  end
     	
     	  local pending_string = function()
****0	    return "-"
     	  end
     	
     	  local running_string = function()
  232	    return "."
     	  end
     	
     	  local status_string = function(short_status, descriptive_status, successes, failures, pendings, ms, options)
    2	    local success_str = s('output.success_plural')
    2	    local failure_str = s('output.failure_plural')
    2	    local pending_str = s('output.pending_plural')
     	
    2	    if successes == 0 then
****0	      success_str = s('output.success_zero')
    2	    elseif successes == 1 then
****0	      success_str = s('output.success_single')
     	    end
     	
    2	    if failures == 0 then
    2	      failure_str = s('output.failure_zero')
****0	    elseif failures == 1 then
****0	      failure_str = s('output.failure_single')
     	    end
     	
    2	    if pendings == 0 then
    2	      pending_str = s('output.pending_zero')
****0	    elseif pendings == 1 then
****0	      pending_str = s('output.pending_single')
     	    end
     	
    2	    if not options.defer_print then
    2	      io.write("\08 ")
    2	      short_status = ""
     	    end
     	
    2	    local formatted_time = ("%.6f"):format(ms):gsub("([0-9])0+$", "%1")
     	
    2	    return short_status.."\n"..
    2	           successes.." "..success_str..", "..
    2	           failures.." "..failure_str..", and "..
    2	           pendings.." "..pending_str.." in "..
    2	           formatted_time.." "..s('output.seconds').."."..descriptive_status
     	  end
     	
     	  local format_statuses = function (statuses, options)
    2	    local short_status = ""
    2	    local descriptive_status = ""
    2	    local successes = 0
    2	    local failures = 0
    2	    local pendings = 0
     	
  234	    for i,status in ipairs(statuses) do
  232	      if status.type == "description" then
****0	        local inner_short_status, inner_descriptive_status, inner_successes, inner_failures, inner_pendings = format_statuses(status, options)
****0	        short_status = short_status..inner_short_status
****0	        descriptive_status = descriptive_status..inner_descriptive_status
****0	        successes = inner_successes + successes
****0	        failures = inner_failures + failures
****0	        pendings = inner_pendings + pendings
  232	      elseif status.type == "success" then
  232	        short_status = short_status..success_string(options)
  232	        successes = successes + 1
****0	      elseif status.type == "failure" then
****0	        short_status = short_status..failure_string(options)
****0	        descriptive_status = descriptive_status..error_description(status, options)
     	
****0	        if options.verbose then
****0	          descriptive_status = descriptive_status.."\n"..status.trace
     	        end
     	
****0	        failures = failures + 1
****0	      elseif status.type == "pending" then
****0	        short_status = short_status..pending_string(options)
****0	        pendings = pendings + 1
     	
****0	        if not options.suppress_pending then
****0	          descriptive_status = descriptive_status..pending_description(status, options)
     	        end
     	      end
     	    end
     	
    2	    return short_status, descriptive_status, successes, failures, pendings
     	  end
     	
    2	  local strings = {
    2	    failure = failure_string,
    2	    success = success_string,
    2	    pending = pending_string,
     	  }
     	
     	  local on_first
    2	  return {
    2	    options = {},
     	
     	    header = function(desc, test_count)
    2	      on_first = true
     	    end,
     	
     	
     	    formatted_status = function(statuses, options, ms)
    2	      local short_status, descriptive_status, successes, failures, pendings = format_statuses(statuses, options)
    2	      return status_string(short_status, descriptive_status, successes, failures, pendings, ms, options)
     	    end,
     	
     	    currently_executing = function(test_status, options)
  232	      if on_first then
    2	        on_first = false
     	      else
  230	        io.write("\08")
     	      end
     	
  232	      io.write(strings[test_status.type](options)..running_string(options))
  232	      io.flush()
     	    end
    2	  }
     	end
     	
    2	return output
     	

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/luassert\assert.lua
==============================================================================
****0	local s = require 'say'
****0	local astate = require 'luassert.state'
     	local obj   -- the returned module table
     	
     	-- list of namespaces
****0	local namespace = {}
     	
     	local errorlevel = function()
     	  -- find the first level, not defined in the same file as this
     	  -- code file to properly report the error
****0	  local level = 1
****0	  local info = debug.getinfo(level)
****0	  local thisfile = (info or {}).source
****0	  while thisfile and thisfile == (info or {}).source do
****0	    level = level + 1
****0	    info = debug.getinfo(level)
     	  end
****0	  if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
****0	  return level
     	end
     	
     	local function extract_keys(assert_string)
     	  -- get a list of token separated by _
  478	  local tokens = {}
 1082	  for token in assert_string:lower():gmatch('[^_]+') do
  604	    table.insert(tokens, token)
     	  end
     	
     	  -- find valid keys by coalescing tokens as needed, starting from the end
  478	  local keys = {}
  478	  local key = nil
 1082	  for i = #tokens, 1, -1 do
  604	    token = tokens[i]
  604	    key = key and (token .. '_' .. key) or token
  604	    if namespace.modifier[key] or namespace.assertion[key] then
  604	      table.insert(keys, 1, key)
  604	      key = nil
     	    end
     	  end
     	
     	  -- if there's anything left we didn't recognize it
  478	  if key then
****0	    error("luassert: unknown modifier/assertion: '" .. key .."'", errorlevel())
     	  end
     	
  478	  return keys
     	end
     	
****0	local __assertion_meta = {
     	  __call = function(self, ...)
  604	    local state = self.state
  604	    local arguments = {...}
  604	    arguments.n = select('#',...)  -- add argument count for trailing nils
  604	    local val = self.callback(state, arguments)
  604	    local data_type = type(val)
     	
  604	    if data_type == "boolean" then
  344	      if val ~= state.mod then
****0	        if state.mod then
****0	          error(s(self.positive_message, obj:format(arguments)) or "assertion failed!", errorlevel())
     	        else
****0	          error(s(self.negative_message, obj:format(arguments)) or "assertion failed!", errorlevel())
     	        end
     	      else
  344	        return state
     	      end
     	    end
  260	    return val
     	  end
     	}
     	
****0	local __state_meta = {
     	
     	  __call = function(self, payload, callback)
  260	    self.payload = payload or rawget(self, "payload")
  260	    if callback then callback(self) end
  260	    return self
     	  end,
     	
     	  __index = function(self, key)
  478	    local keys = extract_keys(key)
     	
     	    -- execute modifiers and assertions
  478	    local ret = nil
 1082	    for _, key in ipairs(keys) do
  604	      if namespace.modifier[key] then
  260	        namespace.modifier[key].state = self
  260	        ret = self(nil, namespace.modifier[key])
  344	      elseif namespace.assertion[key] then
  344	        namespace.assertion[key].state = self
  344	        ret = namespace.assertion[key]
     	      end
     	    end
  478	    return ret
     	  end
     	}
     	
****0	obj = {
  344	  state = function() return setmetatable({mod=true, payload=nil}, __state_meta) end,
     	
     	  -- registers a function in namespace
     	  register = function(self, nspace, name, callback, positive_message, negative_message)
     	    -- register
****0	    local lowername = name:lower()
****0	    if not namespace[nspace] then
****0	      namespace[nspace] = {}
     	    end
****0	    namespace[nspace][lowername] = setmetatable({
     	      callback = callback,
     	      name = lowername,
     	      positive_message=positive_message,
****0	      negative_message=negative_message
****0	    }, __assertion_meta)
     	  end,
     	
     	  -- registers a formatter
     	  -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
     	  add_formatter = function(self, callback)
****0	    astate.add_formatter(callback)
     	  end,
     	
     	  -- unregisters a formatter
     	  remove_formatter = function(self, fmtr)
****0	    astate.remove_formatter(fmtr)
     	  end,
     	
     	  format = function(self, args)
     	    -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
****0	    local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
****0	    for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
****0	      if not nofmt[i] then
****0	        local val = args[i]
****0	        local valfmt = astate.format_argument(val)
****0	        if valfmt == nil then valfmt = tostring(val) end -- no formatter found
****0	        args[i] = valfmt
     	      end
     	    end
****0	    return args
     	  end,
     	
     	  set_parameter = function(self, name, value)
****0	    astate.set_parameter(name, value)
     	  end,
     	  
     	  get_parameter = function(self, name)
****0	    return astate.get_parameter(name)
     	  end,  
     	  
     	  add_spy = function(self, spy)
****0	    astate.add_spy(spy)
     	  end,
     	  
     	  snapshot = function(self)
****0	    return astate.snapshot()
     	  end,
     	}
     	
****0	local __meta = {
     	
     	  __call = function(self, bool, message, ...)
 1906	    if not bool then
****0	      error(message or "assertion failed!", 2)
     	    end
 1906	    return bool , message , ...
     	  end,
     	
     	  __index = function(self, key)
  344	    return rawget(self, key) or self.state()[key]
     	  end,
     	
     	}
     	
****0	return setmetatable(obj, __meta)

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/luassert\assertions.lua
==============================================================================
     	-- module will not return anything, only register assertions with the main assert engine
     	
     	-- assertions take 2 parameters;
     	-- 1) state
     	-- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
     	-- returns; boolean; whether assertion passed
     	
****0	local assert = require('luassert.assert')
****0	local util = require ('luassert.util')
****0	local s = require('say')
     	
     	local function unique(state, arguments)
****0	  local list = arguments[1]
****0	  local deep = arguments[2]
****0	  for k,v in pairs(list) do
****0	    for k2, v2 in pairs(list) do
****0	      if k ~= k2 then
****0	        if deep and util.deepcompare(v, v2, true) then
****0	          return false
     	        else
****0	          if v == v2 then
****0	            return false
     	          end
     	        end
     	      end
     	    end
     	  end
****0	  return true
     	end
     	
     	local function equals(state, arguments)
  112	  local argcnt = arguments.n
  112	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }))
  224	  for i = 2,argcnt  do
  112	    if arguments[1] ~= arguments[i] then
     	      -- switch arguments for proper output message
****0	      util.tinsert(arguments, 1, arguments[i])
****0	      util.tremove(arguments, i + 1)
****0	      return false
     	    end
     	  end
  112	  return true
     	end
     	
     	local function same(state, arguments)
  108	  local argcnt = arguments.n
  108	  assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }))
  108	  local prev = nil
  216	  for i = 2,argcnt  do
  108	    if type(arguments[1]) == 'table' and type(arguments[i]) == 'table' then
  106	      if not util.deepcompare(arguments[1], arguments[i], true) then
     	        -- switch arguments for proper output message
****0	        util.tinsert(arguments, 1, arguments[i])
****0	        util.tremove(arguments, i + 1)
****0	        return false
     	      end
     	    else
    2	      if arguments[1] ~= arguments[i] then
     	        -- switch arguments for proper output message
****0	        util.tinsert(arguments, 1, arguments[i])
****0	        util.tremove(arguments, i + 1)
****0	        return false
     	      end
     	    end
     	  end
  108	  return true
     	end
     	
     	local function truthy(state, arguments)
****0	  return arguments[1] ~= false and arguments[1] ~= nil
     	end
     	
     	local function falsy(state, arguments)
****0	  return not truthy(state, arguments)
     	end
     	
     	local function has_error(state, arguments)
****0	  local func = arguments[1]
****0	  local err_expected = arguments[2]
     	  
****0	  assert(util.callable(func), s("assertion.internal.badargtype", { "error", "function, or callable object", type(func) }))
****0	  local err_actual = nil
     	  --must swap error functions to get the actual error message
****0	  local old_error = error
     	  error = function(err)
****0	    err_actual = err
****0	    return old_error(err)
     	  end
****0	  local status = pcall(func)
****0	  error = old_error
****0	  local val = not status and (err_expected == nil or same(state, {err_expected, err_actual, ["n"] = 2}))
     	
****0	  return val
     	end
     	
     	local function is_true(state, arguments)
   66	  table.insert(arguments, 2, true)
   66	  arguments.n = arguments.n + 1
   66	  return arguments[1] == arguments[2]
     	end
     	
     	local function is_false(state, arguments)
   58	  table.insert(arguments, 2, false)
   58	  arguments.n = arguments.n + 1
   58	  return arguments[1] == arguments[2]
     	end
     	
     	local function is_type(state, arguments, etype)
****0	  table.insert(arguments, 2, "type " .. etype)
****0	  arguments.nofmt = arguments.nofmt or {}
****0	  arguments.nofmt[2] = true
****0	  arguments.n = arguments.n + 1
****0	  return arguments.n > 1 and type(arguments[1]) == etype
     	end
     	
     	local function returned_arguments(state, arguments)
****0	  arguments[1] = tostring(arguments[1])
****0	  arguments[2] = tostring(arguments.n - 1)
****0	  arguments.nofmt = arguments.nofmt or {}
****0	  arguments.nofmt[1] = true
****0	  arguments.nofmt[2] = true
****0	  if arguments.n < 2 then arguments.n = 2 end
****0	  return arguments[1] == arguments[2]
     	end
     	
****0	local function is_boolean(state, arguments)  return is_type(state, arguments, "boolean")  end
****0	local function is_number(state, arguments)   return is_type(state, arguments, "number")   end
****0	local function is_string(state, arguments)   return is_type(state, arguments, "string")   end
****0	local function is_table(state, arguments)    return is_type(state, arguments, "table")    end
****0	local function is_nil(state, arguments)      return is_type(state, arguments, "nil")      end
****0	local function is_userdata(state, arguments) return is_type(state, arguments, "userdata") end
****0	local function is_function(state, arguments) return is_type(state, arguments, "function") end
****0	local function is_thread(state, arguments)   return is_type(state, arguments, "thread")   end
     	
****0	assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")
     	
****0	assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
****0	assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
****0	assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
****0	assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
****0	assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
****0	assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
****0	assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
****0	assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/luassert\modifiers.lua
==============================================================================
     	-- module will not return anything, only register assertions/modifiers with the main assert engine
****0	local assert = require('luassert.assert')
     	
     	local function is(state)
  260	  return state
     	end
     	
     	local function is_not(state)
****0	  state.mod = not state.mod
****0	  return state
     	end
     	
****0	assert:register("modifier", "is", is)
****0	assert:register("modifier", "are", is)
****0	assert:register("modifier", "was", is)
****0	assert:register("modifier", "has", is)
****0	assert:register("modifier", "not", is_not)
****0	assert:register("modifier", "no", is_not)

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/luassert\util.lua
==============================================================================
****0	local util = {}
****0	function util.deepcompare(t1,t2,ignore_mt)
  512	  local ty1 = type(t1)
  512	  local ty2 = type(t2)
  512	  if ty1 ~= ty2 then return false end
     	  -- non-table types can be directly compared
  512	  if ty1 ~= 'table' and ty2 ~= 'table' then return t1 == t2 end
  160	  local mt1 = debug.getmetatable(t1)
  160	  local mt2 = debug.getmetatable(t2)
     	  -- would equality be determined by metatable __eq?
  160	  if mt1 and mt1 == mt2 and mt1.__eq then
     	    -- then use that unless asked not to
****0	    if not ignore_mt then return t1 == t2 end
     	  else -- we can skip the deep comparison below if t1 and t2 share identity
  160	    if t1 == t2 then return true end
     	  end
  566	  for k1,v1 in pairs(t1) do
  406	    local v2 = t2[k1]
  406	    if v2 == nil or not util.deepcompare(v1,v2) then return false end
     	  end
  566	  for k2,_ in pairs(t2) do
     	    -- only check wether each element has a t1 counterpart, actual comparison
     	    -- has been done in first loop above
  406	    if t1[k2] == nil then return false end
     	  end
  160	  return true
     	end
     	
     	-----------------------------------------------
     	-- table.insert() replacement that respects nil values.
     	-- The function will use table field 'n' as indicator of the
     	-- table length, if not set, it will be added.
     	-- @param t table into which to insert
     	-- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
     	-- @param val value to insert
     	-- @return No return values
****0	function util.tinsert(...)
     	  -- check optional POS value
****0	  local args = {...}
****0	  local c = select('#',...)
****0	  local t = args[1]
****0	  local pos = args[2]
****0	  local val = args[3]
****0	  if c < 3 then
****0	    val = pos
****0	    pos = nil
     	  end
     	  -- set length indicator n if not present (+1)
****0	  t.n = (t.n or #t) + 1
****0	  if not pos then
****0	    pos = t.n
****0	  elseif pos > t.n then
     	    -- out of our range
****0	    t[pos] = val
****0	    t.n = pos
     	  end
     	  -- shift everything up 1 pos
****0	  for i = t.n, pos + 1, -1 do
****0	    t[i]=t[i-1]
     	  end
     	  -- add element to be inserted
****0	  t[pos] = val
     	end
     	-----------------------------------------------
     	-- table.remove() replacement that respects nil values.
     	-- The function will use table field 'n' as indicator of the
     	-- table length, if not set, it will be added.
     	-- @param t table from which to remove
     	-- @param pos (optional) position in table to remove
     	-- @return No return values
****0	function util.tremove(t, pos)
     	  -- set length indicator n if not present (+1)
****0	  t.n = t.n or #t
****0	  if not pos then
****0	    pos = t.n
****0	  elseif pos > t.n then
     	    -- out of our range
****0	    t[pos] = nil
****0	    return
     	  end
     	  -- shift everything up 1 pos
****0	  for i = pos, t.n do
****0	    t[i]=t[i+1]
     	  end
     	  -- set size, clean last
****0	  t[t.n] = nil
****0	  t.n = t.n - 1
     	end
     	
     	-----------------------------------------------
     	-- Checks an element to be callable.
     	-- The type must either be a function or have a metatable
     	-- containing an '__call' function.
     	-- @param object element to inspect on being callable or not
     	-- @return boolean, true if the object is callable
****0	function util.callable(object)
****0	  return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
     	end
     	
****0	return util

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\dir.lua
==============================================================================
     	--- Getting directory contents and matching them against wildcards.
     	--
     	-- Dependencies: `pl.utils`, `pl.path`, `pl.tablex`
     	--
     	-- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
     	-- @module pl.dir
     	
****0	local utils = require 'pl.utils'
****0	local path = require 'pl.path'
****0	local is_windows = path.is_windows
****0	local tablex = require 'pl.tablex'
****0	local ldir = path.dir
****0	local chdir = path.chdir
****0	local mkdir = path.mkdir
****0	local rmdir = path.rmdir
****0	local sub = string.sub
****0	local os,pcall,ipairs,pairs,require,setmetatable,_G = os,pcall,ipairs,pairs,require,setmetatable,_G
****0	local remove = os.remove
****0	local append = table.insert
****0	local wrap = coroutine.wrap
****0	local yield = coroutine.yield
****0	local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
****0	local List = utils.stdmt.List
     	
****0	local dir = {}
     	
     	local function assert_dir (n,val)
    2	    assert_arg(n,val,'string',path.isdir,'not a directory',4)
     	end
     	
     	local function assert_file (n,val)
****0	    assert_arg(n,val,'string',path.isfile,'not a file',4)
     	end
     	
     	local function filemask(mask)
    7	    mask = utils.escape(mask)
    7	    return mask:gsub('%%%*','.+'):gsub('%%%?','.')..'$'
     	end
     	
     	--- does the filename match the shell pattern?.
     	-- (cf. fnmatch.fnmatch in Python, 11.8)
     	-- @param file A file name
     	-- @param pattern A shell pattern
     	-- @return true or false
     	-- @raise file and pattern must be strings
****0	function dir.fnmatch(file,pattern)
****0	    assert_string(1,file)
****0	    assert_string(2,pattern)
****0	    return path.normcase(file):find(filemask(pattern)) ~= nil
     	end
     	
     	--- return a list of all files which match the pattern.
     	-- (cf. fnmatch.filter in Python, 11.8)
     	-- @param files A table containing file names
     	-- @param pattern A shell pattern.
     	-- @return list of files
     	-- @raise file and pattern must be strings
****0	function dir.filter(files,pattern)
****0	    assert_arg(1,files,'table')
****0	    assert_string(2,pattern)
****0	    local res = {}
****0	    local mask = filemask(pattern)
****0	    for i,f in ipairs(files) do
****0	        if f:find(mask) then append(res,f) end
     	    end
****0	    return setmetatable(res,List)
     	end
     	
     	local function _listfiles(dir,filemode,match)
****0	    local res = {}
****0	    local check = utils.choose(filemode,path.isfile,path.isdir)
****0	    if not dir then dir = '.' end
****0	    for f in ldir(dir) do
****0	        if f ~= '.' and f ~= '..' then
****0	            local p = path.join(dir,f)
****0	            if check(p) and (not match or match(p)) then
****0	                append(res,p)
     	            end
     	        end
     	    end
****0	    return setmetatable(res,List)
     	end
     	
     	--- return a list of all files in a directory which match the a shell pattern.
     	-- @param dir A directory. If not given, all files in current directory are returned.
     	-- @param mask  A shell pattern. If not given, all files are returned.
     	-- @return lsit of files
     	-- @raise dir and mask must be strings
****0	function dir.getfiles(dir,mask)
****0	    assert_dir(1,dir)
****0	    if mask then assert_string(2,mask) end
     	    local match
****0	    if mask then
****0	        mask = filemask(mask)
     	        match = function(f)
****0	            return f:find(mask)
     	        end
     	    end
****0	    return _listfiles(dir,true,match)
     	end
     	
     	--- return a list of all subdirectories of the directory.
     	-- @param dir A directory
     	-- @return a list of directories
     	-- @raise dir must be a string
****0	function dir.getdirectories(dir)
****0	    assert_dir(1,dir)
****0	    return _listfiles(dir,false)
     	end
     	
     	local function quote_argument (f)
****0	    f = path.normcase(f)
****0	    if f:find '%s' then
****0	        return '"'..f..'"'
     	    else
****0	        return f
     	    end
     	end
     	
     	
     	local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile
     	
     	local function execute_command(cmd,parms)
****0	   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
****0	   local err = path.is_windows and ' > ' or ' 2> '
****0	    cmd = cmd..' '..parms..err..cmd_tmpfile
****0	    local ret = utils.execute(cmd)
****0	    if not ret then
****0	        return false,(utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
     	    else
****0	        return true
     	    end
     	end
     	
     	local function find_ffi_copyfile ()
****0	    if not ffi_checked then
****0	        ffi_checked = true
     	        local res
****0	        res,alien = pcall(require,'alien')
****0	        if not res then
****0	            alien = nil
****0	            res, ffi = pcall(require,'ffi')
     	        end
****0	        if not res then
****0	            ffi = nil
****0	            return
     	        end
     	    else
****0	        return
     	    end
****0	    if alien then
     	        -- register the Win32 CopyFile and MoveFile functions
****0	        local kernel = alien.load('kernel32.dll')
****0	        CopyFile = kernel.CopyFileA
****0	        CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
****0	        MoveFile = kernel.MoveFileA
****0	        MoveFile:types{'string','string',ret='int',abi='stdcall'}
****0	        GetLastError = kernel.GetLastError
****0	        GetLastError:types{ret ='int', abi='stdcall'}
****0	    elseif ffi then
****0	        ffi.cdef [[
****0	            int CopyFileA(const char *src, const char *dest, int iovr);
****0	            int MoveFileA(const char *src, const char *dest);
****0	            int GetLastError();
****0	        ]]
****0	        CopyFile = ffi.C.CopyFileA
****0	        MoveFile = ffi.C.MoveFileA
****0	        GetLastError = ffi.C.GetLastError
     	    end
****0	    win32_errors = {
     	        ERROR_FILE_NOT_FOUND    =         2,
     	        ERROR_PATH_NOT_FOUND    =         3,
     	        ERROR_ACCESS_DENIED    =          5,
     	        ERROR_WRITE_PROTECT    =          19,
     	        ERROR_BAD_UNIT         =          20,
     	        ERROR_NOT_READY        =          21,
     	        ERROR_WRITE_FAULT      =          29,
     	        ERROR_READ_FAULT       =          30,
     	        ERROR_SHARING_VIOLATION =         32,
     	        ERROR_LOCK_VIOLATION    =         33,
     	        ERROR_HANDLE_DISK_FULL  =         39,
     	        ERROR_BAD_NETPATH       =         53,
     	        ERROR_NETWORK_BUSY      =         54,
     	        ERROR_DEV_NOT_EXIST     =         55,
     	        ERROR_FILE_EXISTS       =         80,
     	        ERROR_OPEN_FAILED       =         110,
     	        ERROR_INVALID_NAME      =         123,
     	        ERROR_BAD_PATHNAME      =         161,
     	        ERROR_ALREADY_EXISTS    =         183,
     	    }
     	end
     	
     	local function two_arguments (f1,f2)
****0	    return quote_argument(f1)..' '..quote_argument(f2)
     	end
     	
     	local function file_op (is_copy,src,dest,flag)
****0	    if flag == 1 and path.exists(dest) then
****0	        return false,"cannot overwrite destination"
     	    end
****0	    if is_windows then
     	        -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
****0	        find_ffi_copyfile()
     	        -- fallback if there's no Alien, just use DOS commands *shudder*
     	        -- 'rename' involves a copy and then deleting the source.
****0	        if not CopyFile then
****0	            src = path.normcase(src)
****0	            dest = path.normcase(dest)
****0	            local cmd = is_copy and 'copy' or 'rename'
****0	            local res, err = execute_command('copy',two_arguments(src,dest))
****0	            if not res then return nil,err end
****0	            if not is_copy then
****0	                return execute_command('del',quote_argument(src))
     	            end
     	        else
****0	            if path.isdir(dest) then
****0	                dest = path.join(dest,path.basename(src))
     	            end
     				local ret
****0	            if is_copy then ret = CopyFile(src,dest,flag)
****0	            else ret = MoveFile(src,dest) end
****0	            if ret == 0 then
****0	                local err = GetLastError()
****0	                for name,value in pairs(win32_errors) do
****0	                    if value == err then return false,name end
     	                end
****0	                return false,"Error #"..err
****0	            else return true
     	            end
     	        end
     	    else -- for Unix, just use cp for now
****0	        return execute_command(is_copy and 'cp' or 'mv',
****0	            two_arguments(src,dest))
     	    end
     	end
     	
     	--- copy a file.
     	-- @param src source file
     	-- @param dest destination file or directory
     	-- @param flag true if you want to force the copy (default)
     	-- @return true if operation succeeded
     	-- @raise src and dest must be strings
****0	function dir.copyfile (src,dest,flag)
****0	    assert_string(1,src)
****0	    assert_string(2,dest)
****0	    flag = flag==nil or flag
****0	    return file_op(true,src,dest,flag and 0 or 1)
     	end
     	
     	--- move a file.
     	-- @param src source file
     	-- @param dest destination file or directory
     	-- @return true if operation succeeded
     	-- @raise src and dest must be strings
****0	function dir.movefile (src,dest)
****0	    assert_string(1,src)
****0	    assert_string(2,dest)
****0	    return file_op(false,src,dest,0)
     	end
     	
     	local function _dirfiles(dir,attrib)
****0	    local dirs = {}
****0	    local files = {}
****0	    for f in ldir(dir) do
****0	        if f ~= '.' and f ~= '..' then
****0	            local p = path.join(dir,f)
****0	            local mode = attrib(p,'mode')
****0	            if mode=='directory' then
****0	                append(dirs,f)
     	            else
****0	                append(files,f)
     	            end
     	        end
     	    end
****0	    return setmetatable(dirs,List),setmetatable(files,List)
     	end
     	
     	
     	local function _walker(root,bottom_up,attrib)
****0	    local dirs,files = _dirfiles(root,attrib)
****0	    if not bottom_up then yield(root,dirs,files) end
****0	    for i,d in ipairs(dirs) do
****0	        _walker(root..path.sep..d,bottom_up,attrib)
     	    end
****0	    if bottom_up then yield(root,dirs,files) end
     	end
     	
     	--- return an iterator which walks through a directory tree starting at root.
     	-- The iterator returns (root,dirs,files)
     	-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
     	-- to get the actual full path)
     	-- If bottom_up is false (or not present), then the entries at the current level are returned
     	-- before we go deeper. This means that you can modify the returned list of directories before
     	-- continuing.
     	-- This is a clone of os.walk from the Python libraries.
     	-- @param root A starting directory
     	-- @param bottom_up False if we start listing entries immediately.
     	-- @param follow_links follow symbolic links
     	-- @return an iterator returning root,dirs,files
     	-- @raise root must be a string
****0	function dir.walk(root,bottom_up,follow_links)
****0	    assert_dir(1,root)
     	    local attrib
****0	    if path.is_windows or not follow_links then
****0	        attrib = path.attrib
     	    else
****0	        attrib = path.link_attrib
     	    end
****0	    return wrap(function () _walker(root,bottom_up,attrib) end)
     	end
     	
     	--- remove a whole directory tree.
     	-- @param fullpath A directory path
     	-- @return true or nil
     	-- @return error if failed
     	-- @raise fullpath must be a string
****0	function dir.rmtree(fullpath)
****0	    assert_dir(1,fullpath)
****0	    if path.islink(fullpath) then return false,'will not follow symlink' end
****0	    for root,dirs,files in dir.walk(fullpath,true) do
****0	        for i,f in ipairs(files) do
****0	            remove(path.join(root,f))
     	        end
****0	        rmdir(root)
     	    end
****0	    return true
     	end
     	
     	local dirpat
****0	if path.is_windows then
****0	    dirpat = '(.+)\\[^\\]+$'
     	else
****0	    dirpat = '(.+)/[^/]+$'
     	end
     	
     	local _makepath
****0	function _makepath(p)
     	    -- windows root drive case
****0	    if p:find '^%a:[\\]*$' then
****0	        return true
     	    end
****0	   if not path.isdir(p) then
****0	    local subp = p:match(dirpat)
****0	    local ok, err = _makepath(subp)
****0	    if not ok then return nil, err end
****0	    return mkdir(p)
     	   else
****0	    return true
     	   end
     	end
     	
     	--- create a directory path.
     	-- This will create subdirectories as necessary!
     	-- @param p A directory path
     	-- @return true on success, nil + errormsg on failure
     	-- @raise failure to create
****0	function dir.makepath (p)
****0	    assert_string(1,p)
****0	    return _makepath(path.normcase(path.abspath(p)))
     	end
     	
     	
     	--- clone a directory tree. Will always try to create a new directory structure
     	-- if necessary.
     	-- @param path1 the base path of the source tree
     	-- @param path2 the new base path for the destination
     	-- @param file_fun an optional function to apply on all files
     	-- @param verbose an optional boolean to control the verbosity of the output.
     	--  It can also be a logging function that behaves like print()
     	-- @return true, or nil
     	-- @return error message, or list of failed directory creations
     	-- @return list of failed file operations
     	-- @raise path1 and path2 must be strings
     	-- @usage clonetree('.','../backup',copyfile)
****0	function dir.clonetree (path1,path2,file_fun,verbose)
****0	    assert_string(1,path1)
****0	    assert_string(2,path2)
****0	    if verbose == true then verbose = print end
****0	    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
****0	    local faildirs,failfiles = {},{}
****0	    if not isdir(path1) then return raise 'source is not a valid directory' end
****0	    path1 = abspath(normcase(path1))
****0	    path2 = abspath(normcase(path2))
****0	    if verbose then verbose('normalized:',path1,path2) end
     	    -- particularly NB that the new path isn't fully contained in the old path
****0	    if path1 == path2 then return raise "paths are the same" end
****0	    local i1,i2 = path2:find(path1,1,true)
****0	    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
****0	        return raise 'destination is a subdirectory of the source'
     	    end
****0	    local cp = path.common_prefix (path1,path2)
****0	    local idx = #cp
****0	    if idx == 0 then -- no common path, but watch out for Windows paths!
****0	        if path1:sub(2,2) == ':' then idx = 3 end
     	    end
****0	    for root,dirs,files in dir.walk(path1) do
****0	        local opath = path2..root:sub(idx)
****0	        if verbose then verbose('paths:',opath,root) end
****0	        if not isdir(opath) then
****0	            local ret = dir.makepath(opath)
****0	            if not ret then append(faildirs,opath) end
****0	            if verbose then verbose('creating:',opath,ret) end
     	        end
****0	        if file_fun then
****0	            for i,f in ipairs(files) do
****0	                local p1 = join(root,f)
****0	                local p2 = join(opath,f)
****0	                local ret = file_fun(p1,p2)
****0	                if not ret then append(failfiles,p2) end
****0	                if verbose then
****0	                    verbose('files:',p1,p2,ret)
     	                end
     	            end
     	        end
     	    end
****0	    return true,faildirs,failfiles
     	end
     	
     	--- return an iterator over all entries in a directory tree
     	-- @param d a directory
     	-- @return an iterator giving pathname and mode (true for dir, false otherwise)
     	-- @raise d must be a non-empty string
****0	function dir.dirtree( d )
    2	    assert( d and d ~= "", "directory parameter is missing or empty" )
    2	    local exists, isdir = path.exists, path.isdir
    2	    local sep = path.sep
     	
    2	    local last = sub ( d, -1 )
    2	    if last == sep or last == '/' then
****0	        d = sub( d, 1, -2 )
     	    end
     	
     	    local function yieldtree( dir )
****0	        for entry in ldir( dir ) do
****0	            if entry ~= "." and entry ~= ".." then
****0	                entry = dir .. sep .. entry
****0	                if exists(entry) then  -- Just in case a symlink is broken.
****0	                    local is_dir = isdir(entry)
****0	                    yield( entry, is_dir )
****0	                    if is_dir then
****0	                        yieldtree( entry )
     	                    end
     	                end
     	            end
     	        end
     	    end
     	
    2	    return wrap( function() yieldtree( d ) end )
     	end
     	
     	
     	---	Recursively returns all the file starting at <i>path</i>. It can optionally take a shell pattern and
     	--	only returns files that match <i>pattern</i>. If a pattern is given it will do a case insensitive search.
     	--	@param start_path {string} A directory. If not given, all files in current directory are returned.
     	--	@param pattern {string} A shell pattern. If not given, all files are returned.
     	--	@return Table containing all the files found recursively starting at <i>path</i> and filtered by <i>pattern</i>.
     	--  @raise start_path must be a string
****0	function dir.getallfiles( start_path, pattern )
    2	    assert_dir(1,start_path)
    2	    pattern = pattern or ""
     	
    2	    local files = {}
    2	    local normcase = path.normcase
    9	    for filename, mode in dir.dirtree( start_path ) do
    7	        if not mode then
    7	            local mask = filemask( pattern )
    7	            if normcase(filename):find( mask ) then
    7	                files[#files + 1] = filename
     	            end
     	        end
     	    end
     	
    2	    return files
     	end
     	
****0	return dir

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\path.lua
==============================================================================
     	--- Path manipulation and file queries.
     	--
     	-- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
     	--
     	-- Dependencies: `pl.utils`, `lfs`
     	-- @module pl.path
     	
     	-- imports and locals
****0	local _G = _G
****0	local sub = string.sub
****0	local getenv = os.getenv
****0	local tmpnam = os.tmpname
     	local attributes, currentdir, link_attrib
****0	local package = package
****0	local io = io
****0	local append = table.insert
****0	local ipairs = ipairs
****0	local utils = require 'pl.utils'
****0	local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
     	
     	local attrib
****0	local path = {}
     	
****0	local res,lfs = _G.pcall(_G.require,'lfs')
****0	if res then
****0	    attributes = lfs.attributes
****0	    currentdir = lfs.currentdir
****0	    link_attrib = lfs.symlinkattributes
     	else
****0	    error("pl.path requires LuaFileSystem")
     	end
     	
****0	attrib = attributes
****0	path.attrib = attrib
****0	path.link_attrib = link_attrib
     	
     	--- Lua iterator over the entries of a given directory.
     	-- Behaves like `lfs.dir`
****0	path.dir = lfs.dir
     	
     	--- Creates a directory.
****0	path.mkdir = lfs.mkdir
     	
     	--- Removes a directory.
****0	path.rmdir = lfs.rmdir
     	
     	---- Get the working directory.
****0	path.currentdir = currentdir
     	
     	--- Changes the working directory.
****0	path.chdir = lfs.chdir
     	
     	
     	--- is this a directory?
     	-- @param P A file path
****0	function path.isdir(P)
    4		assert_string(1,P)
    4	    if P:match("\\$") then
****0	        P = P:sub(1,-2)
     	    end
    4	    return attrib(P,'mode') == 'directory'
     	end
     	
     	--- is this a file?.
     	-- @param P A file path
****0	function path.isfile(P)
    2		assert_string(1,P)
    2	    return attrib(P,'mode') == 'file'
     	end
     	
     	-- is this a symbolic link?
     	-- @param P A file path
****0	function path.islink(P)
****0		assert_string(1,P)
****0	    if link_attrib then
****0	        return link_attrib(P,'mode')=='link'
     	    else
****0	        return false
     	    end
     	end
     	
     	--- return size of a file.
     	-- @param P A file path
****0	function path.getsize(P)
****0		assert_string(1,P)
****0	    return attrib(P,'size')
     	end
     	
     	--- does a path exist?.
     	-- @param P A file path
     	-- @return the file path if it exists, nil otherwise
****0	function path.exists(P)
****0		assert_string(1,P)
****0	    return attrib(P,'mode') ~= nil and P
     	end
     	
     	--- Return the time of last access as the number of seconds since the epoch.
     	-- @param P A file path
****0	function path.getatime(P)
****0		assert_string(1,P)
****0	    return attrib(P,'access')
     	end
     	
     	--- Return the time of last modification
     	-- @param P A file path
****0	function path.getmtime(P)
****0	    return attrib(P,'modification')
     	end
     	
     	---Return the system's ctime.
     	-- @param P A file path
****0	function path.getctime(P)
****0		assert_string(1,P)
****0	    return path.attrib(P,'change')
     	end
     	
     	
     	local function at(s,i)
  144	    return sub(s,i,i)
     	end
     	
****0	path.is_windows = utils.dir_separator == '\\'
     	
     	local other_sep
     	-- !constant sep is the directory separator for this platform.
****0	if path.is_windows then
****0	    path.sep = '\\'; other_sep = '/'
****0	    path.dirsep = ';'
     	else
****0	    path.sep = '/'
****0	    path.dirsep = ':'
     	end
****0	local sep,dirsep = path.sep,path.dirsep
     	
     	--- are we running Windows?
     	-- @class field
     	-- @name path.is_windows
     	
     	--- path separator for this platform.
     	-- @class field
     	-- @name path.sep
     	
     	--- separator for PATH for this platform
     	-- @class field
     	-- @name path.dirsep
     	
     	--- given a path, return the directory part and a file part.
     	-- if there's no directory part, the first value will be empty
     	-- @param P A file path
****0	function path.splitpath(P)
    7	    assert_string(1,P)
    7	    local i = #P
    7	    local ch = at(P,i)
  144	    while i > 0 and ch ~= sep and ch ~= other_sep do
  137	        i = i - 1
  137	        ch = at(P,i)
     	    end
    7	    if i == 0 then
****0	        return '',P
     	    else
    7	        return sub(P,1,i-1), sub(P,i+1)
     	    end
     	end
     	
     	--- return an absolute path.
     	-- @param P A file path
     	-- @param pwd optional start path to use (default is current dir)
****0	function path.abspath(P,pwd)
****0	    assert_string(1,P)
****0		if pwd then assert_string(2,pwd) end
****0	    local use_pwd = pwd ~= nil
****0	    if not use_pwd and not currentdir then return P end
****0	    P = P:gsub('[\\/]$','')
****0	    pwd = pwd or currentdir()
****0	    if not path.isabs(P) then
****0	        P = path.join(pwd,P)
****0	    elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
****0	        P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
     	    end
****0	    return path.normpath(P)
     	end
     	
     	--- given a path, return the root part and the extension part.
     	-- if there's no extension part, the second value will be empty
     	-- @param P A file path
****0	function path.splitext(P)
****0	    assert_string(1,P)
****0	    local i = #P
****0	    local ch = at(P,i)
****0	    while i > 0 and ch ~= '.' do
****0	        if ch == sep or ch == other_sep then
****0	            return P,''
     	        end
****0	        i = i - 1
****0	        ch = at(P,i)
     	    end
****0	    if i == 0 then
****0	        return P,''
     	    else
****0	        return sub(P,1,i-1),sub(P,i)
     	    end
     	end
     	
     	--- return the directory part of a path
     	-- @param P A file path
****0	function path.dirname(P)
****0	    assert_string(1,P)
****0	    local p1,p2 = path.splitpath(P)
****0	    return p1
     	end
     	
     	--- return the file part of a path
     	-- @param P A file path
****0	function path.basename(P)
    7	    assert_string(1,P)
    7	    local p1,p2 = path.splitpath(P)
    7	    return p2
     	end
     	
     	--- get the extension part of a path.
     	-- @param P A file path
****0	function path.extension(P)
****0	    assert_string(1,P)
****0	    local p1,p2 = path.splitext(P)
****0	    return p2
     	end
     	
     	--- is this an absolute path?.
     	-- @param P A file path
****0	function path.isabs(P)
****0	    assert_string(1,P)
****0	    if path.is_windows then
****0	        return at(P,1) == '/' or at(P,1)=='\\' or at(P,2)==':'
     	    else
****0	        return at(P,1) == '/'
     	    end
     	end
     	
     	--- return the path resulting from combining the individual paths.
     	-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
     	-- empty elements (except the last) will be ignored.
     	-- @param p1 A file path
     	-- @param p2 A file path
     	-- @param ... more file paths
****0	function path.join(p1,p2,...)
****0	    assert_string(1,p1)
****0	    assert_string(2,p2)
****0	    if select('#',...) > 0 then
****0	        local p = path.join(p1,p2)
****0	        local args = {...}
****0	        for i = 1,#args do
****0	            assert_string(i,args[i])
****0	            p = path.join(p,args[i])
     	        end
****0	        return p
     	    end
****0	    if path.isabs(p2) then return p2 end
****0	    local endc = at(p1,#p1)
****0	    if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
****0	        p1 = p1..path.sep
     	    end
****0	    return p1..p2
     	end
     	
     	--- normalize the case of a pathname. On Unix, this returns the path unchanged;
     	--  for Windows, it converts the path to lowercase, and it also converts forward slashes
     	-- to backward slashes.
     	-- @param P A file path
****0	function path.normcase(P)
    7	    assert_string(1,P)
    7	    if path.is_windows then
    7	        return (P:lower():gsub('/','\\'))
     	    else
****0	        return P
     	    end
     	end
     	
****0	local np_gen1,np_gen2 = '[^SEP]+SEP%.%.SEP?','SEP+%.?SEP'
     	local np_pat1, np_pat2
     	
     	--- normalize a path name.
     	--  A//B, A/./B and A/foo/../B all become A/B.
     	-- @param P a file path
****0	function path.normpath(P)
****0	    assert_string(1,P)
****0	    if path.is_windows then
****0	        if P:match '^\\\\' then -- UNC
****0	            return '\\\\'..path.normpath(P:sub(3))
     	        end
****0	        P = P:gsub('/','\\')
     	    end
****0	    if not np_pat1 then
****0	        np_pat1 = np_gen1:gsub('SEP',sep)
****0	        np_pat2 = np_gen2:gsub('SEP',sep)
     	    end
     	    local k
     	    repeat -- /./ -> /
****0	        P,k = P:gsub(np_pat2,sep)
****0	    until k == 0
     	    repeat -- A/../ -> (empty)
****0	        P,k = P:gsub(np_pat1,'')
****0	    until k == 0
****0	    if P == '' then P = '.' end
****0	    return P
     	end
     	
     	local function ATS (P)
****0	    if at(P,#P) ~= path.sep then
****0	        P = P..path.sep
     	    end
****0	    return path.normcase(P)
     	end
     	
     	--- relative path from current directory or optional start point
     	-- @param P a path
     	-- @param start optional start point (default current directory)
****0	function path.relpath (P,start)
****0	    assert_string(1,P)
****0		if start then assert_string(2,start) end
****0	    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert
****0	    P = normcase(path.abspath(P,start))
****0	    start = start or currentdir()
****0	    start = normcase(start)
****0	    local startl, Pl = split(start,sep), split(P,sep)
****0	    local n = min(#startl,#Pl)
****0	    local k = n+1 -- default value if this loop doesn't bail out!
****0	    for i = 1,n do
****0	        if startl[i] ~= Pl[i] then
****0	            k = i
     	            break
     	        end
     	    end
****0	    local rell = {}
****0	    for i = 1, #startl-k+1 do rell[i] = '..' end
****0	    if k <= #Pl then
****0	        for i = k,#Pl do append(rell,Pl[i]) end
     	    end
****0	    return table.concat(rell,sep)
     	end
     	
     	
     	--- Replace a starting '~' with the user's home directory.
     	-- In windows, if HOME isn't set, then USERPROFILE is used in preference to
     	-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
     	-- @param P A file path
****0	function path.expanduser(P)
****0	    assert_string(1,P)
****0	    if at(P,1) == '~' then
****0	        local home = getenv('HOME')
****0	        if not home then -- has to be Windows
****0	            home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
     	        end
****0	        return home..sub(P,2)
     	    else
****0	        return P
     	    end
     	end
     	
     	
     	---Return a suitable full path to a new temporary file name.
     	-- unlike os.tmpnam(), it always gives you a writeable path (uses TEMP environment variable on Windows)
****0	function path.tmpname ()
****0	    local res = tmpnam()
****0	    if path.is_windows then res = getenv('TEMP')..res end
****0	    return res
     	end
     	
     	--- return the largest common prefix path of two paths.
     	-- @param path1 a file path
     	-- @param path2 a file path
****0	function path.common_prefix (path1,path2)
****0	    assert_string(1,path1)
****0	    assert_string(2,path2)
****0	    path1, path2 = path.normcase(path1), path.normcase(path2)
     	    -- get them in order!
****0	    if #path1 > #path2 then path2,path1 = path1,path2 end
****0	    for i = 1,#path1 do
****0	        local c1 = at(path1,i)
****0	        if c1 ~= at(path2,i) then
****0	            local cp = path1:sub(1,i-1)
****0	            if at(path1,i-1) ~= sep then
****0	                cp = path.dirname(cp)
     	            end
****0	            return cp
     	        end
     	    end
****0	    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
****0	    return path1
     	    --return ''
     	end
     	
     	
     	--- return the full path where a particular Lua module would be found.
     	-- Both package.path and package.cpath is searched, so the result may
     	-- either be a Lua file or a shared library.
     	-- @param mod name of the module
     	-- @return on success: path of module, lua or binary
     	-- @return on error: nil,error string
****0	function path.package_path(mod)
****0	    assert_string(1,mod)
     	    local res
****0	    mod = mod:gsub('%.',sep)
****0	    res = package.searchpath(mod,package.path)
****0	    if res then return res,true end
****0	    res = package.searchpath(mod,package.cpath)
****0	    if res then return res,false end
****0	    return raise 'cannot find module on path'
     	end
     	
     	
     	---- finis -----
****0	return path

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\pretty.lua
==============================================================================
     	--- Pretty-printing Lua tables.
     	-- Also provides a sandboxed Lua table reader and
     	-- a function to present large numbers in human-friendly format.
     	--
     	-- Dependencies: `pl.utils`, `pl.lexer`
     	-- @module pl.pretty
     	
****0	local append = table.insert
****0	local concat = table.concat
****0	local utils = require 'pl.utils'
****0	local lexer = require 'pl.lexer'
****0	local assert_arg = utils.assert_arg
     	
****0	local pretty = {}
     	
     	local function save_string_index ()
****0	    local SMT = getmetatable ''
****0	    if SMT then
****0	        SMT.old__index = SMT.__index
****0	        SMT.__index = nil
     	    end
****0	    return SMT
     	end
     	
     	local function restore_string_index (SMT)
****0	    if SMT then
****0	        SMT.__index = SMT.old__index
     	    end
     	end
     	
     	--- read a string representation of a Lua table.
     	-- Uses load(), but tries to be cautious about loading arbitrary code!
     	-- It is expecting a string of the form '{...}', with perhaps some whitespace
     	-- before or after the curly braces. A comment may occur beforehand.
     	-- An empty environment is used, and
     	-- any occurance of the keyword 'function' will be considered a problem.
     	-- in the given environment - the return value may be `nil`.
     	-- @param s {string} string of the form '{...}', with perhaps some whitespace
     	-- before or after the curly braces.
     	-- @return a table
****0	function pretty.read(s)
****0	    assert_arg(1,s,'string')
****0	    if s:find '^%s*%-%-' then -- may start with a comment..
****0	        s = s:gsub('%-%-.-\n','')
     	    end
****0	    if not s:find '^%s*%b{}%s*$' then return nil,"not a Lua table" end
****0	    if s:find '[^\'"%w_]function[^\'"%w_]' then
****0	        local tok = lexer.lua(s)
****0	        for t,v in tok do
****0	            if t == 'keyword' then
****0	                return nil,"cannot have functions in table definition"
     	            end
     	        end
     	    end
****0	    s = 'return '..s
****0	    local chunk,err = utils.load(s,'tbl','t',{})
****0	    if not chunk then return nil,err end
****0	    local SMT = save_string_index()
****0	    local ok,ret = pcall(chunk)
****0	    restore_string_index(SMT)
****0	    if ok then return ret
     	    else
****0	        return nil,ret
     	    end
     	end
     	
     	--- read a Lua chunk.
     	-- @param s Lua code
     	-- @param env optional environment
     	-- @param paranoid prevent any looping constructs and disable string methods
     	-- @return the environment
****0	function pretty.load (s, env, paranoid)
****0	    env = env or {}
****0	    if paranoid then
****0	        local tok = lexer.lua(s)
****0	        for t,v in tok do
****0	            if t == 'keyword'
****0	                and (v == 'for' or v == 'repeat' or v == 'function' or v == 'goto')
****0	            then
****0	                return nil,"looping not allowed"
     	            end
     	        end
     	    end
****0	    local chunk,err = utils.load(s,'tbl','t',env)
****0	    if not chunk then return nil,err end
****0	    local SMT = paranoid and save_string_index()
****0	    local ok,err = pcall(chunk)
****0	    restore_string_index(SMT)
****0	    if not ok then return nil,err end
****0	    return env
     	end
     	
     	local function quote_if_necessary (v)
****0	    if not v then return ''
     	    else
****0	        if v:find ' ' then v = '"'..v..'"' end
     	    end
****0	    return v
     	end
     	
     	local keywords
     	
     	local function is_identifier (s)
****0	    return type(s) == 'string' and s:find('^[%a_][%w_]*$') and not keywords[s]
     	end
     	
     	local function quote (s)
  232	    if type(s) == 'table' then
****0	        return pretty.write(s,'')
     	    else
  232	        return ('%q'):format(tostring(s))
     	    end
     	end
     	
     	local function index (numkey,key)
****0	    if not numkey then key = quote(key) end
****0	    return '['..key..']'
     	end
     	
     	
     	---	Create a string representation of a Lua table.
     	--  This function never fails, but may complain by returning an
     	--  extra value. Normally puts out one item per line, using
     	--  the provided indent; set the second parameter to '' if
     	--  you want output on one line.
     	--	@param tbl {table} Table to serialize to a string.
     	--	@param space {string} (optional) The indent to use.
     	--	Defaults to two spaces; make it the empty string for no indentation
     	--	@param not_clever {bool} (optional) Use for plain output, e.g {['key']=1}.
     	--	Defaults to false.
     	--  @return a string
     	--  @return a possible error message
****0	function pretty.write (tbl,space,not_clever)
  232	    if type(tbl) ~= 'table' then
  232	        local res = tostring(tbl)
  232	        if type(tbl) == 'string' then return quote(tbl) end
****0	        return res, 'not a table'
     	    end
****0	    if not keywords then
****0	        keywords = lexer.get_keywords()
     	    end
****0	    local set = ' = '
****0	    if space == '' then set = '=' end
****0	    space = space or '  '
****0	    local lines = {}
****0	    local line = ''
****0	    local tables = {}
     	
     	
     	    local function put(s)
****0	        if #s > 0 then
****0	            line = line..s
     	        end
     	    end
     	
     	    local function putln (s)
****0	        if #line > 0 then
****0	            line = line..s
****0	            append(lines,line)
****0	            line = ''
     	        else
****0	            append(lines,s)
     	        end
     	    end
     	
     	    local function eat_last_comma ()
****0	        local n,lastch = #lines
****0	        local lastch = lines[n]:sub(-1,-1)
****0	        if lastch == ',' then
****0	            lines[n] = lines[n]:sub(1,-2)
     	        end
     	    end
     	
     	
     	    local writeit
     	    writeit = function (t,oldindent,indent)
****0	        local tp = type(t)
****0	        if tp ~= 'string' and  tp ~= 'table' then
****0	            putln(quote_if_necessary(tostring(t))..',')
****0	        elseif tp == 'string' then
****0	            if t:find('\n') then
****0	                putln('[[\n'..t..']],')
     	            else
****0	                putln(quote(t)..',')
     	            end
****0	        elseif tp == 'table' then
****0	            if tables[t] then
****0	                putln('<cycle>,')
****0	                return
     	            end
****0	            tables[t] = true
****0	            local newindent = indent..space
****0	            putln('{')
****0	            local used = {}
****0	            if not not_clever then
****0	                for i,val in ipairs(t) do
****0	                    put(indent)
****0	                    writeit(val,indent,newindent)
****0	                    used[i] = true
     	                end
     	            end
****0	            for key,val in pairs(t) do
****0	                local numkey = type(key) == 'number'
****0	                if not_clever then
****0	                    key = tostring(key)
****0	                    put(indent..index(numkey,key)..set)
****0	                    writeit(val,indent,newindent)
     	                else
****0	                    if not numkey or not used[key] then -- non-array indices
****0	                        if numkey or not is_identifier(key) then
****0	                            key = index(numkey,key)
     	                        end
****0	                        put(indent..key..set)
****0	                        writeit(val,indent,newindent)
     	                    end
     	                end
     	            end
****0	            tables[t] = nil
****0	            eat_last_comma()
****0	            putln(oldindent..'},')
     	        else
****0	            putln(tostring(t)..',')
     	        end
     	    end
****0	    writeit(tbl,'',space)
****0	    eat_last_comma()
****0	    return concat(lines,#space > 0 and '\n' or '')
     	end
     	
     	---	Dump a Lua table out to a file or stdout.
     	--	@param t {table} The table to write to a file or stdout.
     	--	@param ... {string} (optional) File name to write too. Defaults to writing
     	--	to stdout.
****0	function pretty.dump (t,...)
****0	    if select('#',...)==0 then
****0	        print(pretty.write(t))
****0	        return true
     	    else
****0	        return utils.writefile(...,pretty.write(t))
     	    end
     	end
     	
****0	local memp,nump = {'B','KiB','MiB','GiB'},{'','K','M','B'}
     	
     	local comma
****0	function comma (val)
****0	    local thou = math.floor(val/1000)
****0	    if thou > 0 then return comma(thou)..','..(val % 1000)
****0	    else return tostring(val) end
     	end
     	
     	--- format large numbers nicely for human consumption.
     	-- @param num a number
     	-- @param kind one of 'M' (memory in KiB etc), 'N' (postfixes are 'K','M' and 'B')
     	-- and 'T' (use commas as thousands separator)
     	-- @param prec number of digits to use for 'M' and 'N' (default 1)
****0	function pretty.number (num,kind,prec)
****0	    local fmt = '%.'..(prec or 1)..'f%s'
****0	    if kind == 'T' then
****0	        return comma(num)
     	    else
     	        local postfixes, fact
****0	        if kind == 'M' then
****0	            fact = 1024
****0	            postfixes = memp
     	        else
****0	            fact = 1000
****0	            postfixes = nump
     	        end
****0	        local div = fact
****0	        local k = 1
****0	        while num >= div and k <= #postfixes do
****0	            div = div * fact
****0	            k = k + 1
     	        end
****0	        div = div / fact
****0	        if k > #postfixes then k = k - 1; div = div/fact end
****0	        if k > 1 then
****0	            return fmt:format(num/div,postfixes[k] or 'duh')
     	        else
****0	            return num..postfixes[1]
     	        end
     	    end
     	end
     	
****0	return pretty

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\tablex.lua
==============================================================================
     	--- Extended operations on Lua tables.
     	--
     	-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
     	--
     	-- Dependencies: `pl.utils`, `pl.types`
     	-- @module pl.tablex
****0	local utils = require ('pl.utils')
****0	local types = require ('pl.types')
****0	local getmetatable,setmetatable,require = getmetatable,setmetatable,require
****0	local tsort,append,remove = table.sort,table.insert,table.remove
****0	local min,max = math.min,math.max
****0	local pairs,type,unpack,next,select,tostring = pairs,type,utils.unpack,next,select,tostring
****0	local function_arg = utils.function_arg
****0	local Set = utils.stdmt.Set
****0	local List = utils.stdmt.List
****0	local Map = utils.stdmt.Map
****0	local assert_arg = utils.assert_arg
     	
****0	local tablex = {}
     	
     	-- generally, functions that make copies of tables try to preserve the metatable.
     	-- However, when the source has no obvious type, then we attach appropriate metatables
     	-- like List, Map, etc to the result.
     	local function setmeta (res,tbl,def)
    4	    local mt = getmetatable(tbl) or def
    4	    return setmetatable(res, mt)
     	end
     	
     	local function makelist (res)
****0	    return setmetatable(res,List)
     	end
     	
     	local function complain (idx,msg)
****0	    error(('argument %d is not %s'):format(idx,msg),3)
     	end
     	
     	local function assert_arg_indexable (idx,val)
    4	    if not types.is_indexable(val) then
****0	        complain(idx,"indexable")
     	    end
     	end
     	
     	local function assert_arg_iterable (idx,val)
****0	    if not types.is_iterable(val) then
****0	        complain(idx,"iterable")
     	    end
     	end
     	
     	local function assert_arg_writeable (idx,val)
****0	    if not types.is_writeable(val) then
****0	        complain(idx,"writeable")
     	    end
     	end
     	
     	--- copy a table into another, in-place.
     	-- @param t1 destination table
     	-- @param t2 source (any iterable object)
     	-- @return first table
****0	function tablex.update (t1,t2)
****0	    assert_arg_writeable(1,t1)
****0	    assert_arg_iterable(2,t2)
****0	    for k,v in pairs(t2) do
****0	        t1[k] = v
     	    end
****0	    return t1
     	end
     	
     	--- total number of elements in this table.
     	-- Note that this is distinct from `#t`, which is the number
     	-- of values in the array part; this value will always
     	-- be greater or equal. The difference gives the size of
     	-- the hash part, for practical purposes. Works for any
     	-- object with a __pairs metamethod.
     	-- @param t a table
     	-- @return the size
****0	function tablex.size (t)
****0	    assert_arg_iterable(1,t)
****0	    local i = 0
****0	    for k in pairs(t) do i = i + 1 end
****0	    return i
     	end
     	
     	--- make a shallow copy of a table
     	-- @param t an iterable source
     	-- @return new table
****0	function tablex.copy (t)
****0	    assert_arg_iterable(1,t)
****0	    local res = {}
****0	    for k,v in pairs(t) do
****0	        res[k] = v
     	    end
****0	    return res
     	end
     	
     	--- make a deep copy of a table, recursively copying all the keys and fields.
     	-- This will also set the copied table's metatable to that of the original.
     	--  @param t A table
     	-- @return new table
****0	function tablex.deepcopy(t)
****0	    if type(t) ~= 'table' then return t end
****0	    assert_arg_iterable(1,t)
****0	    local mt = getmetatable(t)
****0	    local res = {}
****0	    for k,v in pairs(t) do
****0	        if type(v) == 'table' then
****0	            v = tablex.deepcopy(v)
     	        end
****0	        res[k] = v
     	    end
****0	    setmetatable(res,mt)
****0	    return res
     	end
     	
****0	local abs, deepcompare = math.abs
     	
     	--- compare two values.
     	-- if they are tables, then compare their keys and fields recursively.
     	-- @param t1 A value
     	-- @param t2 A value
     	-- @param ignore_mt if true, ignore __eq metamethod (default false)
     	-- @param eps if defined, then used for any number comparisons
     	-- @return true or false
****0	function tablex.deepcompare(t1,t2,ignore_mt,eps)
****0	    local ty1 = type(t1)
****0	    local ty2 = type(t2)
****0	    if ty1 ~= ty2 then return false end
     	    -- non-table types can be directly compared
****0	    if ty1 ~= 'table' then
****0	        if ty1 == 'number' and eps then return abs(t1-t2) < eps end
****0	        return t1 == t2
     	    end
     	    -- as well as tables which have the metamethod __eq
****0	    local mt = getmetatable(t1)
****0	    if not ignore_mt and mt and mt.__eq then return t1 == t2 end
****0	    for k1 in pairs(t1) do
****0	        if t2[k1]==nil then return false end
     	    end
****0	    for k2 in pairs(t2) do
****0	        if t1[k2]==nil then return false end
     	    end
****0	    for k1,v1 in pairs(t1) do
****0	        local v2 = t2[k1]
****0	        if not deepcompare(v1,v2,ignore_mt,eps) then return false end
     	    end
     	
****0	    return true
     	end
     	
****0	deepcompare = tablex.deepcompare
     	
     	--- compare two arrays using a predicate.
     	-- @param t1 an array
     	-- @param t2 an array
     	-- @param cmp A comparison function
****0	function tablex.compare (t1,t2,cmp)
****0	    assert_arg_indexable(1,t1)
****0	    assert_arg_indexable(2,t2)
****0	    if #t1 ~= #t2 then return false end
****0	    cmp = function_arg(3,cmp)
****0	    for k = 1,#t1 do
****0	        if not cmp(t1[k],t2[k]) then return false end
     	    end
****0	    return true
     	end
     	
     	--- compare two list-like tables using an optional predicate, without regard for element order.
     	-- @param t1 a list-like table
     	-- @param t2 a list-like table
     	-- @param cmp A comparison function (may be nil)
****0	function tablex.compare_no_order (t1,t2,cmp)
****0	    assert_arg_indexable(1,t1)
****0	    assert_arg_indexable(2,t2)
****0	    if cmp then cmp = function_arg(3,cmp) end
****0	    if #t1 ~= #t2 then return false end
****0	    local visited = {}
****0	    for i = 1,#t1 do
****0	        local val = t1[i]
     	        local gotcha
****0	        for j = 1,#t2 do if not visited[j] then
     	            local match
****0	            if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
****0	            if match then
****0	                gotcha = j
     	                break
     	            end
****0	        end end
****0	        if not gotcha then return false end
****0	        visited[gotcha] = true
     	    end
****0	    return true
     	end
     	
     	
     	--- return the index of a value in a list.
     	-- Like string.find, there is an optional index to start searching,
     	-- which can be negative.
     	-- @param t A list-like table (i.e. with numerical indices)
     	-- @param val A value
     	-- @param idx index to start; -1 means last element,etc (default 1)
     	-- @return index of value or nil if not found
     	-- @usage find({10,20,30},20) == 2
     	-- @usage find({'a','b','a','c'},'a',2) == 3
****0	function tablex.find(t,val,idx)
****0	    assert_arg_indexable(1,t)
****0	    idx = idx or 1
****0	    if idx < 0 then idx = #t + idx + 1 end
****0	    for i = idx,#t do
****0	        if t[i] == val then return i end
     	    end
****0	    return nil
     	end
     	
     	--- return the index of a value in a list, searching from the end.
     	-- Like string.find, there is an optional index to start searching,
     	-- which can be negative.
     	-- @param t A list-like table (i.e. with numerical indices)
     	-- @param val A value
     	-- @param idx index to start; -1 means last element,etc (default 1)
     	-- @return index of value or nil if not found
     	-- @usage rfind({10,10,10},10) == 3
****0	function tablex.rfind(t,val,idx)
****0	    assert_arg_indexable(1,t)
****0	    idx = idx or #t
****0	    if idx < 0 then idx = #t + idx + 1 end
****0	    for i = idx,1,-1 do
****0	        if t[i] == val then return i end
     	    end
****0	    return nil
     	end
     	
     	
     	--- return the index (or key) of a value in a table using a comparison function.
     	-- @param t A table
     	-- @param cmp A comparison function
     	-- @param arg an optional second argument to the function
     	-- @return index of value, or nil if not found
     	-- @return value returned by comparison function
****0	function tablex.find_if(t,cmp,arg)
****0	    assert_arg_iterable(1,t)
****0	    cmp = function_arg(2,cmp)
****0	    for k,v in pairs(t) do
****0	        local c = cmp(v,arg)
****0	        if c then return k,c end
     	    end
****0	    return nil
     	end
     	
     	--- return a list of all values in a table indexed by another list.
     	-- @param tbl a table
     	-- @param idx an index table (a list of keys)
     	-- @return a list-like table
     	-- @usage index_by({10,20,30,40},{2,4}) == {20,40}
     	-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
****0	function tablex.index_by(tbl,idx)
****0	    assert_arg_indexable(1,tbl)
****0	    assert_arg_indexable(2,idx)
****0	    local res = {}
****0	    for i = 1,#idx do
****0	        res[i] = tbl[idx[i]]
     	    end
****0	    return setmeta(res,tbl,List)
     	end
     	
     	--- apply a function to all values of a table.
     	-- This returns a table of the results.
     	-- Any extra arguments are passed to the function.
     	-- @param fun A function that takes at least one argument
     	-- @param t A table
     	-- @param ... optional arguments
     	-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
****0	function tablex.map(fun,t,...)
****0	    assert_arg_iterable(1,t)
****0	    fun = function_arg(1,fun)
****0	    local res = {}
****0	    for k,v in pairs(t) do
****0	        res[k] = fun(v,...)
     	    end
****0	    return setmeta(res,t)
     	end
     	
     	--- apply a function to all values of a list.
     	-- This returns a table of the results.
     	-- Any extra arguments are passed to the function.
     	-- @param fun A function that takes at least one argument
     	-- @param t a table (applies to array part)
     	-- @param ... optional arguments
     	-- @return a list-like table
     	-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
****0	function tablex.imap(fun,t,...)
****0	    assert_arg_indexable(1,t)
****0	    fun = function_arg(1,fun)
****0	    local res = {}
****0	    for i = 1,#t do
****0	        res[i] = fun(t[i],...) or false
     	    end
****0	    return setmeta(res,t,List)
     	end
     	
     	--- apply a named method to values from a table.
     	-- @param name the method name
     	-- @param t a list-like table
     	-- @param ... any extra arguments to the method
****0	function tablex.map_named_method (name,t,...)
****0	    utils.assert_string(1,name)
****0	    assert_arg_indexable(2,t)
****0	    local res = {}
****0	    for i = 1,#t do
****0	        local val = t[i]
****0	        local fun = val[name]
****0	        res[i] = fun(val,...)
     	    end
****0	    return setmeta(res,t,List)
     	end
     	
     	
     	--- apply a function to all values of a table, in-place.
     	-- Any extra arguments are passed to the function.
     	-- @param fun A function that takes at least one argument
     	-- @param t a table
     	-- @param ... extra arguments
****0	function tablex.transform (fun,t,...)
****0	    assert_arg_iterable(1,t)
****0	    fun = function_arg(1,fun)
****0	    for k,v in pairs(t) do
****0	        t[k] = fun(v,...)
     	    end
     	end
     	
     	--- generate a table of all numbers in a range
     	-- @param start  number
     	-- @param finish number
     	-- @param step optional increment (default 1 for increasing, -1 for decreasing)
****0	function tablex.range (start,finish,step)
****0	    if start == finish then return {start}
****0	    elseif start > finish then return {}
     	    end
****0	    local res = {}
****0	    local k = 1
****0	    if not step then
****0	        if finish > start then step = finish > start and 1 or -1 end
     	    end
****0	    for i=start,finish,step do res[k]=i; k=k+1 end
****0	    return res
     	end
     	
     	--- apply a function to values from two tables.
     	-- @param fun a function of at least two arguments
     	-- @param t1 a table
     	-- @param t2 a table
     	-- @param ... extra arguments
     	-- @return a table
     	-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
****0	function tablex.map2 (fun,t1,t2,...)
****0	    assert_arg_iterable(1,t1)
****0	    assert_arg_iterable(2,t2)
****0	    fun = function_arg(1,fun)
****0	    local res = {}
****0	    for k,v in pairs(t1) do
****0	        res[k] = fun(v,t2[k],...)
     	    end
****0	    return setmeta(res,t1,List)
     	end
     	
     	--- apply a function to values from two arrays.
     	-- The result will be the length of the shortest array.
     	-- @param fun a function of at least two arguments
     	-- @param t1 a list-like table
     	-- @param t2 a list-like table
     	-- @param ... extra arguments
     	-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
****0	function tablex.imap2 (fun,t1,t2,...)
****0	    assert_arg_indexable(2,t1)
****0	    assert_arg_indexable(3,t2)
****0	    fun = function_arg(1,fun)
****0	    local res,n = {},math.min(#t1,#t2)
****0	    for i = 1,n do
****0	        res[i] = fun(t1[i],t2[i],...)
     	    end
****0	    return res
     	end
     	
     	--- 'reduce' a list using a binary function.
     	-- @param fun a function of two arguments
     	-- @param t a list-like table
     	-- @return the result of the function
     	-- @usage reduce('+',{1,2,3,4}) == 10
****0	function tablex.reduce (fun,t)
****0	    assert_arg_indexable(2,t)
****0	    fun = function_arg(1,fun)
****0	    local n = #t
****0	    local res = t[1]
****0	    for i = 2,n do
****0	        res = fun(res,t[i])
     	    end
****0	    return res
     	end
     	
     	--- apply a function to all elements of a table.
     	-- The arguments to the function will be the value,
     	-- the key and <i>finally</i> any extra arguments passed to this function.
     	-- Note that the Lua 5.0 function table.foreach passed the <i>key</i> first.
     	-- @param t a table
     	-- @param fun a function with at least one argument
     	-- @param ... extra arguments
****0	function tablex.foreach(t,fun,...)
****0	    assert_arg_iterable(1,t)
****0	    fun = function_arg(2,fun)
****0	    for k,v in pairs(t) do
****0	        fun(v,k,...)
     	    end
     	end
     	
     	--- apply a function to all elements of a list-like table in order.
     	-- The arguments to the function will be the value,
     	-- the index and <i>finally</i> any extra arguments passed to this function
     	-- @param t a table
     	-- @param fun a function with at least one argument
     	-- @param ... optional arguments
****0	function tablex.foreachi(t,fun,...)
****0	    assert_arg_indexable(1,t)
****0	    fun = function_arg(2,fun)
****0	    for i = 1,#t do
****0	        fun(t[i],i,...)
     	    end
     	end
     	
     	
     	--- Apply a function to a number of tables.
     	-- A more general version of map
     	-- The result is a table containing the result of applying that function to the
     	-- ith value of each table. Length of output list is the minimum length of all the lists
     	-- @param fun a function of n arguments
     	-- @param ... n tables
     	-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
     	-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
     	-- @param fun A function that takes as many arguments as there are tables
****0	function tablex.mapn(fun,...)
****0	    fun = function_arg(1,fun)
****0	    local res = {}
****0	    local lists = {...}
****0	    local minn = 1e40
****0	    for i = 1,#lists do
****0	        minn = min(minn,#(lists[i]))
     	    end
****0	    for i = 1,minn do
****0	        local args,k = {},1
****0	        for j = 1,#lists do
****0	            args[k] = lists[j][i]
****0	            k = k + 1
     	        end
****0	        res[#res+1] = fun(unpack(args))
     	    end
****0	    return res
     	end
     	
     	--- call the function with the key and value pairs from a table.
     	-- The function can return a value and a key (note the order!). If both
     	-- are not nil, then this pair is inserted into the result. If only value is not nil, then
     	-- it is appended to the result.
     	-- @param fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
     	-- @param t A table
     	-- @param ... optional arguments
     	-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
     	-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
****0	function tablex.pairmap(fun,t,...)
****0	    assert_arg_iterable(1,t)
****0	    fun = function_arg(1,fun)
****0	    local res = {}
****0	    for k,v in pairs(t) do
****0	        local rv,rk = fun(k,v,...)
****0	        if rk then
****0	            res[rk] = rv
     	        else
****0	            res[#res+1] = rv
     	        end
     	    end
****0	    return res
     	end
     	
****0	local function keys_op(i,v) return i end
     	
     	--- return all the keys of a table in arbitrary order.
     	--  @param t A table
****0	function tablex.keys(t)
****0	    assert_arg_iterable(1,t)
****0	    return makelist(tablex.pairmap(keys_op,t))
     	end
     	
****0	local function values_op(i,v) return v end
     	
     	--- return all the values of the table in arbitrary order
     	--  @param t A table
****0	function tablex.values(t)
****0	    assert_arg_iterable(1,t)
****0	    return makelist(tablex.pairmap(values_op,t))
     	end
     	
****0	local function index_map_op (i,v) return i,v end
     	
     	--- create an index map from a list-like table. The original values become keys,
     	-- and the associated values are the indices into the original list.
     	-- @param t a list-like table
     	-- @return a map-like table
****0	function tablex.index_map (t)
****0	    assert_arg_indexable(1,t)
****0	    return setmetatable(tablex.pairmap(index_map_op,t),Map)
     	end
     	
****0	local function set_op(i,v) return true,v end
     	
     	--- create a set from a list-like table. A set is a table where the original values
     	-- become keys, and the associated values are all true.
     	-- @param t a list-like table
     	-- @return a set (a map-like table)
****0	function tablex.makeset (t)
****0	    assert_arg_indexable(1,t)
****0	    return setmetatable(tablex.pairmap(set_op,t),Set)
     	end
     	
     	
     	--- combine two tables, either as union or intersection. Corresponds to
     	-- set operations for sets () but more general. Not particularly
     	-- useful for list-like tables.
     	-- @param t1 a table
     	-- @param t2 a table
     	-- @param dup true for a union, false for an intersection.
     	-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
     	-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
     	-- @see tablex.index_map
****0	function tablex.merge (t1,t2,dup)
****0	    assert_arg_iterable(1,t1)
****0	    assert_arg_iterable(2,t2)
****0	    local res = {}
****0	    for k,v in pairs(t1) do
****0	        if dup or t2[k] then res[k] = v end
     	    end
****0	    if dup then
****0	      for k,v in pairs(t2) do
****0	        res[k] = v
     	      end
     	    end
****0	    return setmeta(res,t1,Map)
     	end
     	
     	--- a new table which is the difference of two tables.
     	-- With sets (where the values are all true) this is set difference and
     	-- symmetric difference depending on the third parameter.
     	-- @param s1 a map-like table or set
     	-- @param s2 a map-like table or set
     	-- @param symm symmetric difference (default false)
     	-- @return a map-like table or set
****0	function tablex.difference (s1,s2,symm)
****0	    assert_arg_iterable(1,s1)
****0	    assert_arg_iterable(2,s2)
****0	    local res = {}
****0	    for k,v in pairs(s1) do
****0	        if s2[k] == nil then res[k] = v end
     	    end
****0	    if symm then
****0	        for k,v in pairs(s2) do
****0	            if s1[k] == nil then res[k] = v end
     	        end
     	    end
****0	    return setmeta(res,s1,Map)
     	end
     	
     	--- A table where the key/values are the values and value counts of the table.
     	-- @param t a list-like table
     	-- @param cmp a function that defines equality (otherwise uses ==)
     	-- @return a map-like table
     	-- @see seq.count_map
****0	function tablex.count_map (t,cmp)
****0	    assert_arg_indexable(1,t)
****0	    local res,mask = {},{}
****0	    cmp = function_arg(2,cmp)
****0	    local n = #t
****0	    for i = 1,#t do
****0	        local v = t[i]
****0	        if not mask[v] then
****0	            mask[v] = true
     	            -- check this value against all other values
****0	            res[v] = 1  -- there's at least one instance
****0	            for j = i+1,n do
****0	                local w = t[j]
****0	                if cmp and cmp(v,w) or v == w then
****0	                    res[v] = res[v] + 1
****0	                    mask[w] = true
     	                end
     	            end
     	        end
     	    end
****0	    return setmetatable(res,Map)
     	end
     	
     	--- filter a table's values using a predicate function
     	-- @param t a list-like table
     	-- @param pred a boolean function
     	-- @param arg optional argument to be passed as second argument of the predicate
****0	function tablex.filter (t,pred,arg)
    4	    assert_arg_indexable(1,t)
    4	    pred = function_arg(2,pred)
    4	    local res,k = {},1
   13	    for i = 1,#t do
    9	        local v = t[i]
    9	        if pred(v,arg) then
    4	            res[k] = v
    4	            k = k + 1
     	        end
     	    end
    4	    return setmeta(res,t,List)
     	end
     	
     	--- return a table where each element is a table of the ith values of an arbitrary
     	-- number of tables. It is equivalent to a matrix transpose.
     	-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
****0	function tablex.zip(...)
****0	    return tablex.mapn(function(...) return {...} end,...)
     	end
     	
     	local _copy
****0	function _copy (dest,src,idest,isrc,nsrc,clean_tail)
****0	    idest = idest or 1
****0	    isrc = isrc or 1
     	    local iend
****0	    if not nsrc then
****0	        nsrc = #src
****0	        iend = #src
     	    else
****0	        iend = isrc + min(nsrc-1,#src-isrc)
     	    end
****0	    if dest == src then -- special case
****0	        if idest > isrc and iend >= idest then -- overlapping ranges
****0	            src = tablex.sub(src,isrc,nsrc)
****0	            isrc = 1; iend = #src
     	        end
     	    end
****0	    for i = isrc,iend do
****0	        dest[idest] = src[i]
****0	        idest = idest + 1
     	    end
****0	    if clean_tail then
****0	        tablex.clear(dest,idest)
     	    end
****0	    return dest
     	end
     	
     	--- copy an array into another one, clearing dest after idest+nsrc, if necessary. <br>
     	-- @param dest a list-like table
     	-- @param src a list-like table
     	-- @param idest where to start copying values into destination (default 1)
     	-- @param isrc where to start copying values from source (default 1)
     	-- @param nsrc number of elements to copy from source (default source size)
****0	function tablex.icopy (dest,src,idest,isrc,nsrc)
****0	    assert_arg_indexable(1,dest)
****0	    assert_arg_indexable(2,src)
****0	    return _copy(dest,src,idest,isrc,nsrc,true)
     	end
     	
     	--- copy an array into another one. <br>
     	-- @param dest a list-like table
     	-- @param src a list-like table
     	-- @param idest where to start copying values into destination (default 1)
     	-- @param isrc where to start copying values from source (default 1)
     	-- @param nsrc number of elements to copy from source (default source size)
****0	function tablex.move (dest,src,idest,isrc,nsrc)
****0	    assert_arg_indexable(1,dest)
****0	    assert_arg_indexable(2,src)
****0	    return _copy(dest,src,idest,isrc,nsrc,false)
     	end
     	
****0	function tablex._normalize_slice(self,first,last)
****0	  local sz = #self
****0	  if not first then first=1 end
****0	  if first<0 then first=sz+first+1 end
     	  -- make the range _inclusive_!
****0	  if not last then last=sz end
****0	  if last < 0 then last=sz+1+last end
****0	  return first,last
     	end
     	
     	--- Extract a range from a table, like  'string.sub'.
     	-- If first or last are negative then they are relative to the end of the list
     	-- eg. sub(t,-2) gives last 2 entries in a list, and
     	-- sub(t,-4,-2) gives from -4th to -2nd
     	-- @param t a list-like table
     	-- @param first An index
     	-- @param last An index
     	-- @return a new List
****0	function tablex.sub(t,first,last)
****0	    assert_arg_indexable(1,t)
****0	    first,last = tablex._normalize_slice(t,first,last)
****0	    local res={}
****0	    for i=first,last do append(res,t[i]) end
****0	    return setmeta(res,t,List)
     	end
     	
     	--- set an array range to a value. If it's a function we use the result
     	-- of applying it to the indices.
     	-- @param t a list-like table
     	-- @param val a value
     	-- @param i1 start range (default 1)
     	-- @param i2 end range (default table size)
****0	function tablex.set (t,val,i1,i2)
****0	    assert_arg_indexable(1,t)
****0	    i1,i2 = i1 or 1,i2 or #t
****0	    if types.is_callable(val) then
****0	        for i = i1,i2 do
****0	            t[i] = val(i)
     	        end
     	    else
****0	        for i = i1,i2 do
****0	            t[i] = val
     	        end
     	    end
     	end
     	
     	--- create a new array of specified size with initial value.
     	-- @param n size
     	-- @param val initial value (can be nil, but don't expect # to work!)
     	-- @return the table
****0	function tablex.new (n,val)
****0	    local res = {}
****0	    tablex.set(res,val,1,n)
****0	    return res
     	end
     	
     	--- clear out the contents of a table.
     	-- @param t a table
     	-- @param istart optional start position
****0	function tablex.clear(t,istart)
****0	    istart = istart or 1
****0	    for i = istart,#t do remove(t) end
     	end
     	
     	--- insert values into a table. <br>
     	-- insertvalues(t, [pos,] values) <br>
     	-- similar to table.insert but inserts values from given table "values",
     	-- not the object itself, into table "t" at position "pos".
****0	function tablex.insertvalues(t, ...)
****0	    assert_arg(1,t,'table')
     	    local pos, values
****0	    if select('#', ...) == 1 then
****0	        pos,values = #t+1, ...
     	    else
****0	        pos,values = ...
     	    end
****0	    if #values > 0 then
****0	        for i=#t,pos,-1 do
****0	            t[i+#values] = t[i]
     	        end
****0	        local offset = 1 - pos
****0	        for i=pos,pos+#values-1 do
****0	            t[i] = values[i + offset]
     	        end
     	    end
****0	    return t
     	end
     	
     	--- remove a range of values from a table.
     	-- @param t a list-like table
     	-- @param i1 start index
     	-- @param i2 end index
     	-- @return the table
****0	function tablex.removevalues (t,i1,i2)
****0	    assert_arg(1,t,'table')
****0	    i1,i2 = tablex._normalize_slice(t,i1,i2)
****0	    for i = i1,i2 do
****0	        remove(t,i1)
     	    end
****0	    return t
     	end
     	
     	local _find
     	_find = function (t,value,tables)
****0	    for k,v in pairs(t) do
****0	        if v == value then return k end
     	    end
****0	    for k,v in pairs(t) do
****0	        if not tables[v] and type(v) == 'table' then
****0	            tables[v] = true
****0	            local res = _find(v,value,tables)
****0	            if res then
****0	                res = tostring(res)
****0	                if type(k) ~= 'string' then
****0	                    return '['..k..']'..res
     	                else
****0	                    return k..'.'..res
     	                end
     	            end
     	        end
     	    end
     	end
     	
     	--- find a value in a table by recursive search.
     	-- @param t the table
     	-- @param value the value
     	-- @param exclude any tables to avoid searching
     	-- @usage search(_G,math.sin,{package.path}) == 'math.sin'
     	-- @return a fieldspec, e.g. 'a.b' or 'math.sin'
****0	function tablex.search (t,value,exclude)
****0	    assert_arg_iterable(1,t)
****0	    local tables = {[t]=true}
****0	    if exclude then
****0	        for _,v in pairs(exclude) do tables[v] = true end
     	    end
****0	    return _find(t,value,tables)
     	end
     	
     	--- return an iterator to a table sorted by its keys
     	-- @param t the table
     	-- @param f an optional comparison function (f(x,y) is true if x < y)
     	-- @usage for k,v in tablex.sort(t) do print(k,v) end
     	-- @return an iterator to traverse elements sorted by the keys
****0	function tablex.sort(t,f)
****0	   local keys = {}
****0	   for k in pairs(t) do keys[#keys + 1] = k end
****0	   tsort(keys,f)
****0	   local i = 0
****0	   return function()
****0	      i = i + 1
****0	      return keys[i], t[keys[i]]
     	   end
     	end
     	
     	--- return an iterator to a table sorted by its values
     	-- @param t the table
     	-- @param f an optional comparison function (f(x,y) is true if x < y)
     	-- @usage for k,v in tablex.sortv(t) do print(k,v) end
     	-- @return an iterator to traverse elements sorted by the values
****0	function tablex.sortv(t,f)
****0	   local rev = {}
****0	   for k,v in pairs(t) do rev[v] = k end
****0	   local next = tablex.sort(rev,f)
****0	   return function()
****0	      local value,key = next()
****0	      return key,value
     	   end
     	end
     	
     	--- modifies a table to be read only.
     	-- This only offers weak protection. Tables can still be modified with
     	-- table.insert and rawset.
     	-- @param t the table
     	-- @return the table read only.
****0	function tablex.readonly(t)
****0	    local mt = {
     	        __index=t,
     	        __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
     	        __pairs=function() return pairs(t) end,
     	        __ipairs=function() return ipairs(t) end,
     	        __len=function() return #t end,
****0	        __metatable=false
     	    }
****0	    return setmetatable({}, mt)
     	end
     	
     	
     	
****0	return tablex

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\types.lua
==============================================================================
     	---- Dealing with Detailed Type Information
     	
     	-- Dependencies `pl.utils`
     	-- @module pl.types
     	
****0	local utils = require 'pl.utils'
****0	local types = {}
     	
     	--- is the object either a function or a callable object?.
     	-- @param obj Object to check.
****0	function types.is_callable (obj)
****0	    return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call
     	end
     	
     	--- is the object of the specified type?.
     	-- If the type is a string, then use type, otherwise compare with metatable
     	-- @param obj An object to check
     	-- @param tp String of what type it should be
     	-- @function is_type
****0	types.is_type = utils.is_type
     	
****0	local fileMT = getmetatable(io.stdout)
     	
     	--- a string representation of a type.
     	-- For tables with metatables, we assume that the metatable has a `_name`
     	-- field. Knows about Lua file objects.
     	-- @param obj an object
     	-- @return a string like 'number', 'table' or 'List'
****0	function types.type (obj)
****0	    local t = type(obj)
****0	    if t == 'table' or t == 'userdata' then
****0	        local mt = getmetatable(obj)
****0	        if mt == fileMT then
****0	            return 'file'
     	        else
****0	            return mt._name or "unknown "..t
     	        end
     	    else
****0	        return t
     	    end
     	end
     	
     	--- is this number an integer?
     	-- @param x a number
     	-- @raise error if x is not a number
****0	function types.is_integer (x)
****0	    return math.ceil(x)==x
     	end
     	
     	--- Check if the object is "empty".
     	-- An object is considered empty if it is nil, a table with out any items (key,
     	-- value pairs or indexes), or a string with no content ("").
     	-- @param o The object to check if it is empty.
     	-- @param ignore_spaces If the object is a string and this is true the string is
     	-- considered empty is it only contains spaces.
     	-- @return true if the object is empty, otherwise false.
****0	function types.is_empty(o, ignore_spaces)
****0	    if o == nil or (type(o) == "table" and not next(o)) or (type(o) == "string" and (o == "" or (ignore_spaces and o:match("^%s+$")))) then
****0	        return true
     	    end
****0	    return false
     	end
     	
     	local function check_meta (val)
    4	    if type(val) == 'table' then return true end
****0	    return getmetatable(val)
     	end
     	
     	--- is an object 'array-like'?
     	-- @param val any value.
****0	function types.is_indexable (val)
    4	    local mt = check_meta(val)
    4	    if mt == true then return true end
****0	    return not(mt and mt.__len and mt.__index)
     	end
     	
     	--- can an object be iterated over with `ipairs`?
     	-- @param val any value.
****0	function types.is_iterable (val)
****0	    local mt = check_meta(val)
****0	    if mt == true then return true end
****0	    return not(mt and mt.__pairs)
     	end
     	
     	--- can an object accept new key/pair values?
     	-- @param val any value.
****0	function types.is_writeable (val)
****0	    local mt = check_meta(val)
****0	    if mt == true then return true end
****0	    return not(mt and mt.__newindex)
     	end
     	
     	-- Strings that should evaluate to true.
****0	local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
     	-- Conditions types should evaluate to true.
****0	local true_types = {
     	    boolean=function(o, true_strs, check_objs) return o end,
     	    string=function(o, true_strs, check_objs)
****0	        if trues[o:lower()] then
****0	            return true
     	        end
     	        -- Check alternative user provided strings.
****0	        for _,v in ipairs(true_strs or {}) do
****0	            if type(v) == "string" and o == v:lower() then
****0	                return true
     	            end
     	        end
****0	        return false
     	    end,
     	    number=function(o, true_strs, check_objs) return o ~= 0 end,
****0	    table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
     	}
     	--- Convert to a boolean value.
     	-- True values are:
     	--
     	-- * boolean: true.
     	-- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
     	-- * number: Any non-zero value.
     	-- * table: Is not empty and `check_objs` is true.
     	-- * object: Is not `nil` and `check_objs` is true.
     	--
     	-- @param o The object to evaluate.
     	-- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
     	-- This should be a List of strings. E.g. "ja" to support German.
     	-- @param[opt] check_objs True if objects should be evaluated. Default is to evaluate objects as true if not nil
     	-- or if it is a table and it is not empty.
     	-- @return true if the input evaluates to true, otherwise false.
****0	function types.to_bool(o, true_strs, check_objs)
     	    local true_func
****0	    if true_strs then
****0	        utils.assert_arg(2, true_strs, "table")
     	    end
****0	    true_func = true_types[type(o)]
****0	    if true_func then
****0	        return true_func(o, true_strs, check_objs)
****0	    elseif check_objs and o ~= nil then
****0	        return true
     	    end
****0	    return false
     	end
     	
     	
****0	return types

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/pl\utils.lua
==============================================================================
     	--- Generally useful routines.
     	-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
     	-- @module pl.utils
****0	local format,gsub,byte = string.format,string.gsub,string.byte
****0	local compat = require 'pl.compat'
****0	local clock = os.clock
****0	local stdout = io.stdout
****0	local append = table.insert
****0	local unpack = rawget(_G,'unpack') or rawget(table,'unpack')
     	
****0	local collisions = {}
     	
****0	local utils = {
     	    _VERSION = "1.2.1",
     	    lua51 = compat.lua51,
     	    setfenv = compat.setfenv,
     	    getfenv = compat.getfenv,
     	    load = compat.load,
     	    execute = compat.execute,
     	    dir_separator = _G.package.config:sub(1,1),
****0	    unpack = unpack
     	}
     	
     	--- end this program gracefully.
     	-- @param code The exit code or a message to be printed
     	-- @param ... extra arguments for message's format'
     	-- @see utils.fprintf
****0	function utils.quit(code,...)
****0	    if type(code) == 'string' then
****0	        utils.fprintf(io.stderr,code,...)
****0	        code = -1
     	    else
****0	        utils.fprintf(io.stderr,...)
     	    end
****0	    io.stderr:write('\n')
****0	    os.exit(code)
     	end
     	
     	--- print an arbitrary number of arguments using a format.
     	-- @param fmt The format (see string.format)
     	-- @param ... Extra arguments for format
****0	function utils.printf(fmt,...)
****0	    utils.assert_string(1,fmt)
****0	    utils.fprintf(stdout,fmt,...)
     	end
     	
     	--- write an arbitrary number of arguments to a file using a format.
     	-- @param f File handle to write to.
     	-- @param fmt The format (see string.format).
     	-- @param ... Extra arguments for format
****0	function utils.fprintf(f,fmt,...)
****0	    utils.assert_string(2,fmt)
****0	    f:write(format(fmt,...))
     	end
     	
     	local function import_symbol(T,k,v,libname)
****0	    local key = rawget(T,k)
     	    -- warn about collisions!
****0	    if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
****0	        utils.printf("warning: '%s.%s' overrides existing symbol\n",libname,k)
     	    end
****0	    rawset(T,k,v)
     	end
     	
     	local function lookup_lib(T,t)
****0	    for k,v in pairs(T) do
****0	        if v == t then return k end
     	    end
****0	    return '?'
     	end
     	
****0	local already_imported = {}
     	
     	--- take a table and 'inject' it into the local namespace.
     	-- @param t The Table
     	-- @param T An optional destination table (defaults to callers environment)
****0	function utils.import(t,T)
****0	    T = T or _G
****0	    t = t or utils
****0	    if type(t) == 'string' then
****0	        t = require (t)
     	    end
****0	    local libname = lookup_lib(T,t)
****0	    if already_imported[t] then return end
****0	    already_imported[t] = libname
****0	    for k,v in pairs(t) do
****0	        import_symbol(T,k,v,libname)
     	    end
     	end
     	
****0	utils.patterns = {
     	    FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',
     	    INTEGER = '[+%-%d]%d*',
     	    IDEN = '[%a_][%w_]*',
****0	    FILE = '[%a%.\\][:%][%w%._%-\\]*'
     	}
     	
     	--- escape any 'magic' characters in a string
     	-- @param s The input string
****0	function utils.escape(s)
    7	    utils.assert_string(1,s)
    7	    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
     	end
     	
     	--- return either of two values, depending on a condition.
     	-- @param cond A condition
     	-- @param value1 Value returned if cond is true
     	-- @param value2 Value returned if cond is false (can be optional)
****0	function utils.choose(cond,value1,value2)
****0	    if cond then return value1
****0	    else return value2
     	    end
     	end
     	
     	local raise
     	
     	--- return the contents of a file as a string
     	-- @param filename The file path
     	-- @param is_bin open in binary mode
     	-- @return file contents
****0	function utils.readfile(filename,is_bin)
****0	    local mode = is_bin and 'b' or ''
****0	    utils.assert_string(1,filename)
****0	    local f,err = io.open(filename,'r'..mode)
****0	    if not f then return utils.raise (err) end
****0	    local res,err = f:read('*a')
****0	    f:close()
****0	    if not res then return raise (err) end
****0	    return res
     	end
     	
     	--- write a string to a file
     	-- @param filename The file path
     	-- @param str The string
     	-- @return true or nil
     	-- @return error message
     	-- @raise error if filename or str aren't strings
****0	function utils.writefile(filename,str)
****0	    utils.assert_string(1,filename)
****0	    utils.assert_string(2,str)
****0	    local f,err = io.open(filename,'w')
****0	    if not f then return raise(err) end
****0	    f:write(str)
****0	    f:close()
****0	    return true
     	end
     	
     	--- return the contents of a file as a list of lines
     	-- @param filename The file path
     	-- @return file contents as a table
     	-- @raise errror if filename is not a string
****0	function utils.readlines(filename)
****0	    utils.assert_string(1,filename)
****0	    local f,err = io.open(filename,'r')
****0	    if not f then return raise(err) end
****0	    local res = {}
****0	    for line in f:lines() do
****0	        append(res,line)
     	    end
****0	    f:close()
****0	    return res
     	end
     	
     	--- split a string into a list of strings separated by a delimiter.
     	-- @param s The input string
     	-- @param re A Lua string pattern; defaults to '%s+'
     	-- @param plain don't use Lua patterns
     	-- @param n optional maximum number of splits
     	-- @return a list-like table
     	-- @raise error if s is not a string
****0	function utils.split(s,re,plain,n)
    4	    utils.assert_string(1,s)
    4	    local find,sub,append = string.find, string.sub, table.insert
    4	    local i1,ls = 1,{}
    4	    if not re then re = '%s+' end
    4	    if re == '' then return {s} end
     	    while true do
    4	        local i2,i3 = find(s,re,i1,plain)
    4	        if not i2 then
    4	            local last = sub(s,i1)
    4	            if last ~= '' then append(ls,last) end
    4	            if #ls == 1 and ls[1] == '' then
****0	                return {}
     	            else
    4	                return ls
     	            end
     	        end
****0	        append(ls,sub(s,i1,i2-1))
****0	        if n and #ls == n then
****0	            ls[#ls] = sub(s,i1)
****0	            return ls
     	        end
****0	        i1 = i3+1
     	    end
     	end
     	
     	--- split a string into a number of values.
     	-- @param s the string
     	-- @param re the delimiter, default space
     	-- @return n values
     	-- @usage first,next = splitv('jane:doe',':')
     	-- @see split
****0	function utils.splitv (s,re)
****0	    return unpack(utils.split(s,re))
     	end
     	
     	--- convert an array of values to strings.
     	-- @param t a list-like table
     	-- @param temp buffer to use, otherwise allocate
     	-- @param tostr custom tostring function, called with (value,index).
     	-- Otherwise use `tostring`
     	-- @return the converted buffer
****0	function utils.array_tostring (t,temp,tostr)
****0	    temp, tostr = temp or {}, tostr or tostring
****0	    for i = 1,#t do
****0	        temp[i] = tostr(t[i],i)
     	    end
****0	    return temp
     	end
     	
     	--- execute a shell command and return the output.
     	-- This function redirects the output to tempfiles and returns the content of those files.
     	-- @param cmd a shell command
     	-- @param bin boolean, if true, read output as binary file
     	-- @return true if successful
     	-- @return actual return code
     	-- @return stdout output (string)
     	-- @return errout output (string)
****0	function utils.executeex(cmd, bin)
     	    local mode
****0	    local outfile = os.tmpname()
****0	    local errfile = os.tmpname()
     	
****0	    if utils.dir_separator == '\\' then
****0	        outfile = os.getenv('TEMP')..outfile
****0	        errfile = os.getenv('TEMP')..errfile
     	    end
****0	    cmd = cmd .. [[ >"]]..outfile..[[" 2>"]]..errfile..[["]]
     	
****0	    local success, retcode = utils.execute(cmd)
****0	    local outcontent = utils.readfile(outfile, bin)
****0	    local errcontent = utils.readfile(errfile, bin)
****0	    os.remove(outfile)
****0	    os.remove(errfile)
****0	    return success, retcode, (outcontent or ""), (errcontent or "")
     	end
     	
     	--- 'memoize' a function (cache returned value for next call).
     	-- This is useful if you have a function which is relatively expensive,
     	-- but you don't know in advance what values will be required, so
     	-- building a table upfront is wasteful/impossible.
     	-- @param func a function of at least one argument
     	-- @return a function with at least one argument, which is used as the key.
****0	function utils.memoize(func)
****0	    return setmetatable({}, {
     	        __index = function(self, k, ...)
****0	            local v = func(k,...)
****0	            self[k] = v
****0	            return v
     	        end,
****0	        __call = function(self, k) return self[k] end
     	    })
     	end
     	
     	
****0	utils.stdmt = {
     	    List = {_name='List'}, Map = {_name='Map'},
****0	    Set = {_name='Set'}, MultiMap = {_name='MultiMap'}
     	}
     	
****0	local _function_factories = {}
     	
     	--- associate a function factory with a type.
     	-- A function factory takes an object of the given type and
     	-- returns a function for evaluating it
     	-- @param mt metatable
     	-- @param fun a callable that returns a function
****0	function utils.add_function_factory (mt,fun)
****0	    _function_factories[mt] = fun
     	end
     	
     	local function _string_lambda(f)
****0	    local raise = utils.raise
****0	    if f:find '^|' or f:find '_' then
****0	        local args,body = f:match '|([^|]*)|(.+)'
****0	        if f:find '_' then
****0	            args = '_'
****0	            body = f
     	        else
****0	            if not args then return raise 'bad string lambda' end
     	        end
****0	        local fstr = 'return function('..args..') return '..body..' end'
****0	        local fn,err = utils.load(fstr)
****0	        if not fn then return raise(err) end
****0	        fn = fn()
****0	        return fn
****0	    else return raise 'not a string lambda'
     	    end
     	end
     	
     	--- an anonymous function as a string. This string is either of the form
     	-- '|args| expression' or is a function of one argument, '_'
     	-- @param lf function as a string
     	-- @return a function
     	-- @usage string_lambda '|x|x+1' (2) == 3
     	-- @usage string_lambda '_+1 (2) == 3
     	-- @function utils.string_lambda
****0	utils.string_lambda = utils.memoize(_string_lambda)
     	
     	local ops
     	
     	--- process a function argument.
     	-- This is used throughout Penlight and defines what is meant by a function:
     	-- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
     	-- such as '>' or '#'. If a function factory has been registered for the type, it will
     	-- be called to get the function.
     	-- @param idx argument index
     	-- @param f a function, operator string, or callable object
     	-- @param msg optional error message
     	-- @return a callable
     	-- @raise if idx is not a number or if f is not callable
****0	function utils.function_arg (idx,f,msg)
    4	    utils.assert_arg(1,idx,'number')
    4	    local tp = type(f)
    4	    if tp == 'function' then return f end  -- no worries!
     	    -- ok, a string can correspond to an operator (like '==')
****0	    if tp == 'string' then
****0	        if not ops then ops = require 'pl.operator'.optable end
****0	        local fn = ops[f]
****0	        if fn then return fn end
****0	        local fn, err = utils.string_lambda(f)
****0	        if not fn then error(err..': '..f) end
****0	        return fn
****0	    elseif tp == 'table' or tp == 'userdata' then
****0	        local mt = getmetatable(f)
****0	        if not mt then error('not a callable object',2) end
****0	        local ff = _function_factories[mt]
****0	        if not ff then
****0	            if not mt.__call then error('not a callable object',2) end
****0	            return f
     	        else
****0	            return ff(f) -- we have a function factory for this type!
     	        end
     	    end
****0	    if not msg then msg = " must be callable" end
****0	    if idx > 0 then
****0	        error("argument "..idx..": "..msg,2)
     	    else
****0	        error(msg,2)
     	    end
     	end
     	
     	--- bind the first argument of the function to a value.
     	-- @param fn a function of at least two values (may be an operator string)
     	-- @param p a value
     	-- @return a function such that f(x) is fn(p,x)
     	-- @raise same as @{function_arg}
     	-- @see func.bind1
****0	function utils.bind1 (fn,p)
****0	    fn = utils.function_arg(1,fn)
****0	    return function(...) return fn(p,...) end
     	end
     	
     	--- bind the second argument of the function to a value.
     	-- @param fn a function of at least two values (may be an operator string)
     	-- @param p a value
     	-- @return a function such that f(x) is fn(x,p)
     	-- @raise same as @{function_arg}
****0	function utils.bind2 (fn,p)
****0	    fn = utils.function_arg(1,fn)
****0	    return function(x,...) return fn(x,p,...) end
     	end
     	
     	
     	--- assert that the given argument is in fact of the correct type.
     	-- @param n argument index
     	-- @param val the value
     	-- @param tp the type
     	-- @param verify an optional verfication function
     	-- @param msg an optional custom message
     	-- @param lev optional stack position for trace, default 2
     	-- @raise if the argument n is not the correct type
     	-- @usage assert_arg(1,t,'table')
     	-- @usage assert_arg(n,val,'string',path.isdir,'not a directory')
****0	function utils.assert_arg (n,val,tp,verify,msg,lev)
   44	    if type(val) ~= tp then
****0	        error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
     	    end
   44	    if verify and not verify(val) then
****0	        error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
     	    end
     	end
     	
     	--- assert the common case that the argument is a string.
     	-- @param n argument index
     	-- @param val a value that must be a string
     	-- @raise val must be a string
****0	function utils.assert_string (n,val)
   38	    utils.assert_arg(n,val,'string',nil,nil,3)
     	end
     	
****0	local err_mode = 'default'
     	
     	--- control the error strategy used by Penlight.
     	-- Controls how <code>utils.raise</code> works; the default is for it
     	-- to return nil and the error string, but if the mode is 'error' then
     	-- it will throw an error. If mode is 'quit' it will immediately terminate
     	-- the program.
     	-- @param mode - either 'default', 'quit'  or 'error'
     	-- @see utils.raise
****0	function utils.on_error (mode)
****0	    if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
****0	      err_mode = mode
     	    else
     	      -- fail loudly
****0	      if err_mode == 'default' then err_mode = 'error' end
****0	      utils.raise("Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'")
     	    end
     	end
     	
     	--- used by Penlight functions to return errors.  Its global behaviour is controlled
     	-- by <code>utils.on_error</code>
     	-- @param err the error string.
     	-- @see utils.on_error
****0	function utils.raise (err)
****0	    if err_mode == 'default' then return nil,err
****0	    elseif err_mode == 'quit' then utils.quit(err)
****0	    else error(err,2)
     	    end
     	end
     	
     	--- is the object of the specified type?.
     	-- If the type is a string, then use type, otherwise compare with metatable
     	-- @param obj An object to check
     	-- @param tp String of what type it should be
****0	function utils.is_type (obj,tp)
****0	    if type(tp) == 'string' then return type(obj) == tp end
****0	    local mt = getmetatable(obj)
****0	    return tp == mt
     	end
     	
****0	raise = utils.raise
     	
     	--- load a code string or bytecode chunk.
     	-- @param code Lua code as a string or bytecode
     	-- @param name for source errors
     	-- @param mode kind of chunk, 't' for text, 'b' for bytecode, 'bt' for all (default)
     	-- @param env  the environment for the new chunk (default nil)
     	-- @return compiled chunk
     	-- @return error message (chunk is nil)
     	-- @function utils.load
     	
     	---------------
     	-- Get environment of a function.
     	-- With Lua 5.2, may return nil for a function with no global references!
     	-- Based on code by [Sergey Rozhenko](http://lua-users.org/lists/lua-l/2010-06/msg00313.html)
     	-- @param f a function or a call stack reference
     	-- @function utils.setfenv
     	
     	---------------
     	-- Set environment of a function
     	-- @param f a function or a call stack reference
     	-- @param env a table that becomes the new environment of `f`
     	-- @function utils.setfenv
     	
     	--- execute a shell command.
     	-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
     	-- @param cmd a shell command
     	-- @return true if successful
     	-- @return actual return code
     	-- @function utils.execute
     	
****0	return utils
     	
     	

==============================================================================
E:\Lua\rocks\systree/share/lua/5.1/say/init.lua
==============================================================================
****0	local registry = { }
     	local current_namespace
     	local fallback_namespace
     	
****0	local s = {
     	
     	  _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
     	  _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
     	  _VERSION     = "Say 1.2",
     	
     	  set_namespace = function(self, namespace)
****0	    current_namespace = namespace
****0	    if not registry[current_namespace] then
****0	      registry[current_namespace] = {}
     	    end
     	  end,
     	
     	  set_fallback = function(self, namespace)
****0	    fallback_namespace = namespace
****0	    if not registry[fallback_namespace] then
****0	      registry[fallback_namespace] = {}
     	    end
     	  end,
     	
     	  set = function(self, key, value)
****0	    registry[current_namespace][key] = value
     	  end
     	}
     	
****0	local __meta = {
     	  __call = function(self, key, vars)
  232	    vars = vars or {}
     	
  232	    local str = registry[current_namespace][key] or registry[fallback_namespace][key]
     	
  232	    if str == nil then
****0	      return nil
     	    end
  232	    str = tostring(str)
  232	    local strings = {}
     	
  892	    for i,v in ipairs(vars) do
  660	      table.insert(strings, tostring(v))
     	    end
     	
  232	    return #strings > 0 and str:format(unpack(strings)) or str
     	  end,
     	
     	  __index = function(self, key)
****0	    return registry[key]
     	  end
     	}
     	
****0	s:set_fallback('en')
****0	s:set_namespace('en')
     	
****0	if _TEST then
****0	  s._registry = registry -- force different name to make sure with _TEST behaves exactly as without _TEST
     	end
     	
****0	return setmetatable(s, __meta)

==============================================================================
E:\Lua\rocks\systree\lib\luarocks\rocks\busted\1.10.0-1\bin\busted_bootstrap
==============================================================================
     	-- Busted command-line runner
     	
****0	local cli = require 'cliargs'
****0	local utils = require 'pl.utils'
****0	local path = require 'pl.path'
****0	local tablex = require 'pl.tablex'
****0	local busted = require 'busted'
     	
****0	local defaultoutput = busted.defaultoutput
****0	local defaultpattern = busted.defaultpattern
****0	local defaultlua = busted.defaultlua
****0	local lpathprefix = busted.lpathprefix
****0	local cpathprefix = busted.cpathprefix
****0	local ansicolors = require "ansicolors"
     	
****0	cli:set_name("busted")
****0	cli:add_flag("--version", "prints the program's version and exits")
     	
****0	cli:optarg("ROOT", "test script file/folder. Folders will be traversed for any file that matches the --pattern option.", "spec", 1)
     	
****0	cli:add_option("-o, --output=LIBRARY", "output library to load", defaultoutput)
****0	cli:add_option("-l, --lua=luajit", "path to the execution environment (luajit or lua), picks first available", defaultlua)
****0	cli:add_option("-d, --cwd=cwd", "path to current working directory", "./")
****0	cli:add_option("-p, --pattern=pattern", "only run test files matching the Lua pattern", defaultpattern)
****0	cli:add_option("-t, --tags=tags", "only run tests with these #tags")
****0	cli:add_option("--exclude-tags=tags", "do not run tests with these #tags, takes precedence over --tags")
****0	cli:add_option("-m, --lpath=path", "optional path to be prefixed to the Lua module search path", lpathprefix)
****0	cli:add_option("--cpath=path", "optional path to be prefixed to the Lua C module search path", cpathprefix)
****0	cli:add_option("-r, --run=run", "config to run from .busted file")
****0	cli:add_option("--lang=LANG", "language for error messages", "en")
****0	cli:add_flag("-c, --coverage", "do code coverage analysis (requires 'LuaCov' to be installed)")
     	
****0	cli:add_flag("-v, --verbose", "verbose output of errors")
****0	cli:add_flag("-s, --enable-sound", "executes 'say' command if available")
****0	cli:add_flag("--suppress-pending", "suppress 'pending' test output")
****0	cli:add_flag("--defer-print", "defer print to when test suite is complete")
     	
****0	local args = cli:parse_args()
     	
****0	if args then
****0	  if args.version then
****0	    return print(busted._VERSION)
     	  end
     	
****0	  local fpath = args.d
     	
****0	  local tasks = nil
****0	  local bfile = path.normpath(path.join(fpath, ".busted"))
****0	  local success, err = pcall(function() tasks = loadfile(bfile)() end)
     	
****0	  if args.run ~= "" then
****0	    if not success then
****0	      return print(err or "")
****0	    elseif type(tasks) ~= "table" then
****0	      return print("Aborting: "..bfile.." file does not return a table.")
     	    end
     	
****0	    local runConfig = tasks[args.run]
     	
****0	    if type(runConfig) == "table" then
****0	      args = tablex.merge(args, runConfig, true)
     	    else
****0	      return print("Aborting: task '"..args.run.."' not found, or not a table")
     	    end
     	  else
****0	    if success and type(tasks.default) == "table" then
****0	      args = tablex.merge(args, tasks.default, true)
     	    end
     	  end
     	
****0	  local root_file = path.normpath(path.join(fpath, args.ROOT))
     	
****0	  if args.coverage then
****0	    local result, luacov = pcall(require, "luacov.runner")
****0	    if not result then
****0	      return print("LuaCov not found on the system, try running without --coverage option, or install LuaCov first")
     	    end
     	    -- call it to start
****0	    luacov()
     	    -- exclude busted files
    2	    table.insert(luacov.configuration.exclude, "busted_bootstrap$")
    2	    table.insert(luacov.configuration.exclude, "busted%.")
    2	    table.insert(luacov.configuration.exclude, "luassert%.")
    2	    table.insert(luacov.configuration.exclude, "say%.")
    2	    table.insert(luacov.configuration.exclude, "pl%.")
     	  end
     	
    2	  if #args.lpath > 0 then
    2	    lpathprefix = args.lpath
    2	    lpathprefix = lpathprefix:gsub("^%.[/%\\]", fpath )
    2	    lpathprefix = lpathprefix:gsub(";%.[/%\\]", ";" .. fpath)
    2	    package.path = (lpathprefix .. ";" .. package.path):gsub(";;",";")
     	  end
     	
    2	  if #args.cpath > 0 then
    2	    cpathprefix = args.cpath
    2	    cpathprefix = cpathprefix:gsub("^%.[/%\\]", fpath )
    2	    cpathprefix = cpathprefix:gsub(";%.[/%\\]", ";" .. fpath)
    2	    package.cpath = (cpathprefix .. ";" .. package.cpath):gsub(";;",";")
     	  end
     	
    2	  local options = {
    2	    path = fpath,
    2	    lang = args.lang,
    2	    root_file = root_file,
    2	    pattern = args.pattern ~= "" and args.pattern or defaultpattern,
    2	    verbose = args.verbose,
    2	    suppress_pending = args["suppress-pending"],
    2	    defer_print = args["defer-print"],
    2	    sound = args.s,
    2	    cwd = args.d,
    2	    tags = utils.split(args.t, ","),
    2	    excluded_tags = utils.split(args["exclude-tags"], ","),
    2	    output = args.output or defaultoutput,
    2	    success_messages = busted.success_messages or nil,
    2	    failure_messages = busted.failure_messages or nil,
    2	    filelist = nil,
     	  }
     	
     	  -- We report an error if the same tag appears in both 'options.tags'
     	  -- and 'options.excluded_tags' because it does not make sense for the
     	  -- user to tell Busted to include and exclude the same tests at the
     	  -- same time.
    2	  for _,excluded in ipairs(options.excluded_tags) do
****0	    for _,included in ipairs(options.tags) do
****0	      if excluded == included then
****0	        print("Cannot use --tags and --exclude-tags for the same tags")
****0	        os.exit(1)
     	      end
     	    end
     	  end
     	  
     	  -- execute tests
    2	  local status_string, failures = busted(options)
     	
    2	  print((status_string or "").."\n")
     	
    2	  os.exit(failures)
     	end
     	

==============================================================================
Summary
==============================================================================

508	0	100.00%	.\.\functional_facilities_spec.lua
170	1	99.42%	.\functional.lua
30	58	34.09%	E:\Lua\rocks\2.1\lua\luarocks\loader.lua
9	167	5.11%	E:\Lua\rocks\2.1\lua\luarocks\path.lua
205	190	51.90%	E:\Lua\rocks\systree/share/lua/5.1/busted\core.lua
12	45	21.05%	E:\Lua\rocks\systree/share/lua/5.1/busted\done.lua
4	12	25.00%	E:\Lua\rocks\systree/share/lua/5.1/busted\loop\default.lua
2	33	5.71%	E:\Lua\rocks\systree/share/lua/5.1/busted\moon.lua
48	34	58.54%	E:\Lua\rocks\systree/share/lua/5.1/busted\output\plain_terminal.lua
39	41	48.75%	E:\Lua\rocks\systree/share/lua/5.1/luassert\assert.lua
19	74	20.43%	E:\Lua\rocks\systree/share/lua/5.1/luassert\assertions.lua
1	9	10.00%	E:\Lua\rocks\systree/share/lua/5.1/luassert\modifiers.lua
14	35	28.57%	E:\Lua\rocks\systree/share/lua/5.1/luassert\util.lua
19	212	8.23%	E:\Lua\rocks\systree/share/lua/5.1/pl\dir.lua
20	183	9.85%	E:\Lua\rocks\systree/share/lua/5.1/pl\path.lua
5	143	3.38%	E:\Lua\rocks\systree/share/lua/5.1/pl\pretty.lua
12	376	3.09%	E:\Lua\rocks\systree/share/lua/5.1/pl\tablex.lua
3	50	5.66%	E:\Lua\rocks\systree/share/lua/5.1/pl\types.lua
19	170	10.05%	E:\Lua\rocks\systree/share/lua/5.1/pl\utils.lua
8	17	32.00%	E:\Lua\rocks\systree/share/lua/5.1/say/init.lua
35	58	37.63%	E:\Lua\rocks\systree\lib\luarocks\rocks\busted\1.10.0-1\bin\busted_bootstrap
------------------------
1182	1908	38.25%	
